using Controller.Utilities;
using System;
using System.Collections.Generic;
using System.Text;

namespace Controller.Network.Protocol
{
    enum PROTOCOL_PACKET : byte
    {
        HEADER = 0x1,
        BLOCK = 0x2
    }

    class CProtocol
    {
        public delegate void delOnPacketReceived(CPacket Packet);
        public event delOnPacketReceived OnPacketReceived;
        public delegate void delOnHeaderReceived(CPacketHeader PacketHeader);
        public event delOnHeaderReceived OnHeaderReceived;
        public delegate void delOnBlockReceived(string strPacketIdent);
        public event delOnBlockReceived OnBlockReceived;

        private List<CPacket> m_lstQueueRecvPacket = null;

        const Int32 Header_Length = 2;
        const Int32 Block_Length = 3;

        public CProtocol()
        {
            m_lstQueueRecvPacket = new List<CPacket>();
        }

        public CPacket CreatePacket(Byte Packet, String strArguments)
        {
            return this.CreatePacket(Packet, UnicodeEncoding.Unicode.GetBytes(strArguments));
        }

        public CPacket CreatePacket(Byte Packet, Byte[] arr_bArguments)
        {
            try
            {
                //Split Buffer to 128-byte long Blocks
                List<Byte[]> lstBlockBuffers = CUtils.SplitBytes(arr_bArguments, 512);

                List<CPacketBlock> lstBlocks = new List<CPacketBlock>();

                //Create Blocks
                foreach (Byte[] arr_bBuffer in lstBlockBuffers.ToArray())
                {
                    CPacketBlock Block = new CPacketBlock();
                    Block.Block_ID = lstBlocks.Count + 1;
                    string strBuffer = UnicodeEncoding.Unicode.GetString(arr_bBuffer);
                    Block.Block_Buffer = arr_bBuffer;
                    lstBlocks.Add(Block);
                }

                //Create Packet Header
                CPacketHeader Header = CPacketHeader.CreateHeader(Packet, lstBlocks.Count);

                //Create Packet
                CPacket SendPacket = new CPacket(Header);
                SendPacket.Data_Blocks = lstBlocks;

                return SendPacket;
            }
            catch { }
            return null;
        }

        CPacketHeader GetHeaderFromBuffer(Byte[] arr_bBuffer)
        {
            try
            {
                String strBuffer = UnicodeEncoding.Unicode.GetString(arr_bBuffer, 2, arr_bBuffer.Length - 2);

                if (String.IsNullOrEmpty(strBuffer)) return null;

                String[] arr_strData = strBuffer.Split('|');

                if (arr_strData.Length != Header_Length) return null;

                CPacketHeader PacketHeader = new CPacketHeader();
                PacketHeader.Packet_Ident = arr_strData[0];
                PacketHeader.Packet = arr_bBuffer[1];

                if (!Int32.TryParse(arr_strData[1], out PacketHeader.Block_Amount)) return null;

                return PacketHeader;

            }
            catch { }
            return null;
        }

        void ProcessHeader(Byte[] arr_bBuffer)
        {
            CPacketHeader Header = this.GetHeaderFromBuffer(arr_bBuffer);

            if (Header == null) return;

            CPacket Packet = new CPacket(Header);

            for (int i = 0; i < Packet.PacketHeader.Block_Amount; i++)
            {
                CPacketBlock Block = new CPacketBlock();
                Block.Block_ID = Packet.Data_Blocks.Count + 1;

                Packet.Data_Blocks.Add(Block);
            }

            if(!Packet.IsFinished())
            {
	            lock (m_lstQueueRecvPacket)
	            {
	                m_lstQueueRecvPacket.Add(Packet);

                    if (this.OnHeaderReceived != null)
                        this.OnHeaderReceived.Invoke(Packet.PacketHeader);
	            }
            }
            else
            {
            	if(this.OnPacketReceived != null)
            		this.OnPacketReceived.Invoke(Packet);
            }
        }

        bool GetBlockDataFromBuffer(Byte[] arr_bBuffer, out String strPacketIdent, out Int32 iBlockID, out Byte[] arr_bBlockBuffer)
        {
            strPacketIdent = String.Empty;
            iBlockID = 0;
            arr_bBlockBuffer = null;

            try
            {
                String strBuffer = UnicodeEncoding.Unicode.GetString(arr_bBuffer, 1, arr_bBuffer.Length - 1);

                if (String.IsNullOrEmpty(strBuffer)) return false;

                String[] arr_strData = strBuffer.Split('|');

                if (arr_strData.Length != Block_Length) return false;

                strPacketIdent = arr_strData[0];

                if (!Int32.TryParse(arr_strData[1], out iBlockID)) return false;

                arr_bBlockBuffer = Convert.FromBase64String(arr_strData[2]);

                return true;
            }
            catch { }
            return false;
        }

        void ProcessBlock(Byte[] arr_bBuffer)
        {
            String strPacketIdent;
            Int32 iBlockID;
            Byte[] arr_bBlockBuffer;

            if (!this.GetBlockDataFromBuffer(arr_bBuffer, out strPacketIdent, out iBlockID, out arr_bBlockBuffer))
            {
                return;
            }

            lock (m_lstQueueRecvPacket)
            {
                //Loop Through all Packets
                for (int iPacketIndex = 0; iPacketIndex < m_lstQueueRecvPacket.Count; iPacketIndex++)
                {
                    CPacket Packet = m_lstQueueRecvPacket[iPacketIndex];

                    if (Packet.PacketHeader.Packet_Ident != strPacketIdent) continue;

                    lock (Packet.Data_Blocks)
                    {
                        //Loop through all Blocks
                        for (int iBlockIndex = 0; iBlockIndex < Packet.Data_Blocks.Count; iBlockIndex++)
                        {
                            CPacketBlock Block = Packet.Data_Blocks[iBlockIndex];

                            if (Block.IsFinished || Block.Block_ID != iBlockID) continue;

                            //Replace Block with Received Buffer
                            Block.Block_Buffer = arr_bBlockBuffer;

                            //Block is done
                            Block.IsFinished = true;

                            //Replace Packet Block
                            Packet.Data_Blocks[iBlockIndex] = Block;

                            //Replace Packet
                            m_lstQueueRecvPacket[iPacketIndex] = Packet;
                        }

                        if (this.OnBlockReceived != null)
                            this.OnBlockReceived.Invoke(strPacketIdent);
                    }

                    if (Packet.IsFinished())
                    {
                        if (this.OnPacketReceived != null)
                        {
                            this.OnPacketReceived.Invoke(Packet);
                        }

                        m_lstQueueRecvPacket.RemoveAt(iPacketIndex);
                    }
                }
            }
        }

        public bool ProcessBuffer(Byte[] arr_bBuffer)
        {
            try
            {
                PROTOCOL_PACKET Packet = (PROTOCOL_PACKET)arr_bBuffer[0];

                switch (Packet)
                {
                    case PROTOCOL_PACKET.HEADER:
                        this.ProcessHeader(arr_bBuffer);
                        break;
                    case PROTOCOL_PACKET.BLOCK:
                        this.ProcessBlock(arr_bBuffer);
                        break;
                    default: return false;
                }
                return true;
            }
            catch { }
            return false;
        }
    }
}
